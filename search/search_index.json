{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"PYGENMET # GENETICS ALGORITHMS WITH PYTHON Ibon Mart\u00ednez-Arranz 2024-06-09 About me # I'm Ibon Mart\u00ednez-Arranz, with a BSc in Mathematics and MScs in Applied Statistics and Mathematical Modeling. Since 2010, I've been with OWL Metabolomics , initially as a researcher and now Head of the Data Science Department, focusing on Machine Learning Prediction, Statistical Computations, and supporting R&D projects. Introduction # This repository contains the documentation of pygenmet , a genetic algorithms package developed in Python. This book includes a collection of functions and examples, written in Python, that shows how to use the PyGenMet package. Rendering the manual # To compile or generate the documentation with MkDocs try this from console: Clone the repository: $ git clone https://github.com/imarranz/pygenmet.git Render the manual with MkDocs : $ mkdocs build Citation # I publish each release of PyGenMet on Zenodo and here is a list of version: Version Date DOI v1.0.0 August 22, 2021 If you'd like to cite this package, instead of a specific version, use the following DOI: https://doi.org/10.5281/zenodo.5233539 . Here is the bibtex entry for the book: @software{ibon_martinez_arranz_2021_5233539, author = {Ibon Mart\u00ednez-Arranz}, title = {imarranz/pygenmet: v1.0.0}, month = aug, year = 2021, publisher = {Zenodo}, version = {v1.0.0}, doi = {10.5281/zenodo.5233539}, url = {https://doi.org/10.5281/zenodo.5233539} }","title":"Introduction"},{"location":"index.html#pygenmet","text":"GENETICS ALGORITHMS WITH PYTHON Ibon Mart\u00ednez-Arranz 2024-06-09","title":"PYGENMET"},{"location":"index.html#about_me","text":"I'm Ibon Mart\u00ednez-Arranz, with a BSc in Mathematics and MScs in Applied Statistics and Mathematical Modeling. Since 2010, I've been with OWL Metabolomics , initially as a researcher and now Head of the Data Science Department, focusing on Machine Learning Prediction, Statistical Computations, and supporting R&D projects.","title":"About me"},{"location":"index.html#introduction","text":"This repository contains the documentation of pygenmet , a genetic algorithms package developed in Python. This book includes a collection of functions and examples, written in Python, that shows how to use the PyGenMet package.","title":"Introduction"},{"location":"index.html#rendering_the_manual","text":"To compile or generate the documentation with MkDocs try this from console: Clone the repository: $ git clone https://github.com/imarranz/pygenmet.git Render the manual with MkDocs : $ mkdocs build","title":"Rendering the manual"},{"location":"index.html#citation","text":"I publish each release of PyGenMet on Zenodo and here is a list of version: Version Date DOI v1.0.0 August 22, 2021 If you'd like to cite this package, instead of a specific version, use the following DOI: https://doi.org/10.5281/zenodo.5233539 . Here is the bibtex entry for the book: @software{ibon_martinez_arranz_2021_5233539, author = {Ibon Mart\u00ednez-Arranz}, title = {imarranz/pygenmet: v1.0.0}, month = aug, year = 2021, publisher = {Zenodo}, version = {v1.0.0}, doi = {10.5281/zenodo.5233539}, url = {https://doi.org/10.5281/zenodo.5233539} }","title":"Citation"},{"location":"package/introduction.html","text":"Introduction # Nonalcoholic fatty liver disease (NAFLD) is a consequence of defects in diverse metabolic pathways or nutritional effects that involve a hepatic accumulation of triglycerides {cite} barr_obesity-dependent_2012 . Features of these deviations might determine whether NAFLD progresses to nonalcoholic steatohepatitis (NASH). We investigated whether the diverse defects observed in patients with NAFLD are due to different NAFLD subtypes with specific serum metabolomic profiles and whether these can distinguish patients with NASH from patients with simple steatosis {cite} martinez-arranz_metabolomicbased_2018 . We collected liver and serum from several murine models, which have genetic alterations, nutritional alterations or both. I also analyzed serum metabolomes {cite} martinez-arranz_enhancing_2015 of 535 patients with biopsy-proven NAFLD (353 with simple steatosis and 182 with NASH) and compared them with serum metabolomes of these murine models {cite} barr_liquid_2010,alonso_metabolomic_2017,iruarrizaga-lejarreta_role_2017 . In a previous analysis, we identified several subtypes of NAFLD using cluster analysis and we recognized markers that differentiate steatosis from NASH in each subtype. In this study, a specific Genetic Algorithm (GA) has been developed to improve the identification of these subtypes in a human cohort and create a scalable methodology to identify subtypes of NAFLD. The final aim of this work is to develop a methodology for precision care in NAFLD. The genetic algorithm has been developed in Python language and NumPy Style Python Docstrings 1 2 has been used to document the package. Genetic algorithm schema and functions associated with each step. INITIAL POPULATION/POPULATION _get_father(): See {ref} tools:_get_father function. _get_population(): See {ref} tools:_get_population function. FITNESS _get_fitness(): See {ref} fitness:_get_fitness function. _get_fitness_robust(): See {ref} fitness:_get_fitness_robust function. _get_fitness_l(): See {ref} fitness:_get_fitness_l function. SELECTION _selection(): See {ref} operators:_selection function. CROSSOVER _crossover(): See {ref} operators:_crossover function. _arithmetic_crossover(): See {ref} operators:_arithmetic_crossover function. MUTATION _mutation(): See {ref} operators:_mutation function. Genetic Algorithms Applied to Translational Strategy in NASH. Learning from Mouse Models. Poster presented in the II Jornadas Doctorales de la UPV/EHU 2019. Bibliography # {bibliography} bibliography/introduction.bib :style: alpha # plain, unsrt, unsrtalpha example numpy style python docstrings \u21a9 numpydoc docstring guide \u21a9","title":"Introduction"},{"location":"package/introduction.html#introduction","text":"Nonalcoholic fatty liver disease (NAFLD) is a consequence of defects in diverse metabolic pathways or nutritional effects that involve a hepatic accumulation of triglycerides {cite} barr_obesity-dependent_2012 . Features of these deviations might determine whether NAFLD progresses to nonalcoholic steatohepatitis (NASH). We investigated whether the diverse defects observed in patients with NAFLD are due to different NAFLD subtypes with specific serum metabolomic profiles and whether these can distinguish patients with NASH from patients with simple steatosis {cite} martinez-arranz_metabolomicbased_2018 . We collected liver and serum from several murine models, which have genetic alterations, nutritional alterations or both. I also analyzed serum metabolomes {cite} martinez-arranz_enhancing_2015 of 535 patients with biopsy-proven NAFLD (353 with simple steatosis and 182 with NASH) and compared them with serum metabolomes of these murine models {cite} barr_liquid_2010,alonso_metabolomic_2017,iruarrizaga-lejarreta_role_2017 . In a previous analysis, we identified several subtypes of NAFLD using cluster analysis and we recognized markers that differentiate steatosis from NASH in each subtype. In this study, a specific Genetic Algorithm (GA) has been developed to improve the identification of these subtypes in a human cohort and create a scalable methodology to identify subtypes of NAFLD. The final aim of this work is to develop a methodology for precision care in NAFLD. The genetic algorithm has been developed in Python language and NumPy Style Python Docstrings 1 2 has been used to document the package. Genetic algorithm schema and functions associated with each step. INITIAL POPULATION/POPULATION _get_father(): See {ref} tools:_get_father function. _get_population(): See {ref} tools:_get_population function. FITNESS _get_fitness(): See {ref} fitness:_get_fitness function. _get_fitness_robust(): See {ref} fitness:_get_fitness_robust function. _get_fitness_l(): See {ref} fitness:_get_fitness_l function. SELECTION _selection(): See {ref} operators:_selection function. CROSSOVER _crossover(): See {ref} operators:_crossover function. _arithmetic_crossover(): See {ref} operators:_arithmetic_crossover function. MUTATION _mutation(): See {ref} operators:_mutation function. Genetic Algorithms Applied to Translational Strategy in NASH. Learning from Mouse Models. Poster presented in the II Jornadas Doctorales de la UPV/EHU 2019.","title":"Introduction"},{"location":"package/introduction.html#bibliography","text":"{bibliography} bibliography/introduction.bib :style: alpha # plain, unsrt, unsrtalpha example numpy style python docstrings \u21a9 numpydoc docstring guide \u21a9","title":"Bibliography"},{"location":"package/package/class.html","text":"CLASS chromosome # Import the pygenmet package from pygenmet import * With Pyhton a class can be created. A class provides a lot of functionalities. We can create a new class and then we can create a new type of object in Python. This new class allows new instances and these instances can also have methods . The class chromosome has been created to optimization the algorithm. The docstring associated to the chromosome class is the following. ?chromosome The class chromosome has a copy of its genes, its fitness and the number of No NAFLD samples and NAFLD samples for print purposes. Attributes ---------- Methods ------- print() Prints the chromosome to_json() Notes ----- The representation of a chromosome is the following way 0110101101 ... 0110101101 || 0110110011 ... 0110110011 6 6 0.8945 ------------------------- ------------------------- ----- ----- ------ A B C D E Description of the representation: A] Wild Type Genes B] Knock-Out Genes C] Number of Wild Type cases selected D] Number of Knock-out cases selected E] The fitness value. The value of the adaptation for this chromosome Examples -------- >>> CH = chromosome('01101011010110110011', 0.8945, 10, 10) >>> print(\"Genes: {}\".format(CH.Genes)) Genes: 01101011010110110011 >>> print(\"WT Genes: {}\".format(CH.WT_Genes)) WT Genes: 0110101101 >>> print(\"KO Genes: {}\".format(CH.KO_Genes)) KO Genes: 0110110011 >>> print(\"Fitness: {}\".format(CH.Fitness)) Fitness: 0.8945 >>> CH.print() CH = chromosome('0110101101011000111101101011010110001111', 0.4125, 10, 30) print(\"Genes: {}\".format(CH.Genes)) Genes: 0110101101011000111101101011010110001111 print(\"WT Genes: {}\".format(CH.WT_Genes)) WT Genes: 0110101101 print(\"KO Genes: {}\".format(CH.KO_Genes)) KO Genes: 011000111101101011010110001111 print(\"Fitness: {}\".format(CH.Fitness)) Fitness: 0.4125 Methods # A Python method is like a Python function, except it is associated with object/classes. Methods in python are very similar to functions except for two major differences: The method is implicitly used for an object for which it is called. The method is accessible to data that is contained within the class. The chromosome class has currently two methods: print() to_json() print() # The print() method allows to show the chromosome information on the screen or in a file. The print() method has an argument, N , and with this argument we can customized the number of alleles to print. This method print first de Wild Types genes and second the KO genes separated by ||. The number of alleles equal to 1 for each gen is also printed. At last, the fitness function value is shown. CH.print(N = 3) 011 ... 101 || 011 ... 111 6 18 0.4125 CH.print(N = 5) 01101 ... 01101 || 01100 ... 01111 6 18 0.4125 to_json() # JavaScript Object Notation , also known as JSON , is an open standard file format, that uses human-readable text to store and transmit data objects consisting of attribute\u2013value pairs and array data types. It is also very easy for computers to parse and generate. The JSON is a very common data format. CH.to_json(path_or_buf = 'out.json') file out.json has the following structure: {\"chromosome\": [{\"Genes\": \"0110101101011000111101101011010110001111\", \"Fitness\": 0.4125, \"WT_Genes\": \"0110101101\", \"KO_Genes\": \"011000111101101011010110001111\"}]}","title":"Class"},{"location":"package/package/class.html#class_chromosome","text":"Import the pygenmet package from pygenmet import * With Pyhton a class can be created. A class provides a lot of functionalities. We can create a new class and then we can create a new type of object in Python. This new class allows new instances and these instances can also have methods . The class chromosome has been created to optimization the algorithm. The docstring associated to the chromosome class is the following. ?chromosome The class chromosome has a copy of its genes, its fitness and the number of No NAFLD samples and NAFLD samples for print purposes. Attributes ---------- Methods ------- print() Prints the chromosome to_json() Notes ----- The representation of a chromosome is the following way 0110101101 ... 0110101101 || 0110110011 ... 0110110011 6 6 0.8945 ------------------------- ------------------------- ----- ----- ------ A B C D E Description of the representation: A] Wild Type Genes B] Knock-Out Genes C] Number of Wild Type cases selected D] Number of Knock-out cases selected E] The fitness value. The value of the adaptation for this chromosome Examples -------- >>> CH = chromosome('01101011010110110011', 0.8945, 10, 10) >>> print(\"Genes: {}\".format(CH.Genes)) Genes: 01101011010110110011 >>> print(\"WT Genes: {}\".format(CH.WT_Genes)) WT Genes: 0110101101 >>> print(\"KO Genes: {}\".format(CH.KO_Genes)) KO Genes: 0110110011 >>> print(\"Fitness: {}\".format(CH.Fitness)) Fitness: 0.8945 >>> CH.print() CH = chromosome('0110101101011000111101101011010110001111', 0.4125, 10, 30) print(\"Genes: {}\".format(CH.Genes)) Genes: 0110101101011000111101101011010110001111 print(\"WT Genes: {}\".format(CH.WT_Genes)) WT Genes: 0110101101 print(\"KO Genes: {}\".format(CH.KO_Genes)) KO Genes: 011000111101101011010110001111 print(\"Fitness: {}\".format(CH.Fitness)) Fitness: 0.4125","title":"CLASS chromosome"},{"location":"package/package/class.html#methods","text":"A Python method is like a Python function, except it is associated with object/classes. Methods in python are very similar to functions except for two major differences: The method is implicitly used for an object for which it is called. The method is accessible to data that is contained within the class. The chromosome class has currently two methods: print() to_json()","title":"Methods"},{"location":"package/package/class.html#print","text":"The print() method allows to show the chromosome information on the screen or in a file. The print() method has an argument, N , and with this argument we can customized the number of alleles to print. This method print first de Wild Types genes and second the KO genes separated by ||. The number of alleles equal to 1 for each gen is also printed. At last, the fitness function value is shown. CH.print(N = 3) 011 ... 101 || 011 ... 111 6 18 0.4125 CH.print(N = 5) 01101 ... 01101 || 01100 ... 01111 6 18 0.4125","title":"print()"},{"location":"package/package/class.html#to_json","text":"JavaScript Object Notation , also known as JSON , is an open standard file format, that uses human-readable text to store and transmit data objects consisting of attribute\u2013value pairs and array data types. It is also very easy for computers to parse and generate. The JSON is a very common data format. CH.to_json(path_or_buf = 'out.json') file out.json has the following structure: {\"chromosome\": [{\"Genes\": \"0110101101011000111101101011010110001111\", \"Fitness\": 0.4125, \"WT_Genes\": \"0110101101\", \"KO_Genes\": \"011000111101101011010110001111\"}]}","title":"to_json()"},{"location":"package/package/examples.html","text":"Examples # Import the pygenmet package from pygenmet import * import pandas as pd import numpy as np import random import datetime We define a new fitness function. Definition of a simple fitness function # We define a simple fitness function. This function always returns the 1.0 value. def my_own_get_fitness(genes, nwt, nko, dwt, dko, obj): p = 1.0 return p Now, we generate 10 initial solutions (by _get_father_ function) and we can see the fitness function for each solution. nwt = 15 nko = 25 dwt = pd.DataFrame(np.array(random.choices('01', k = nwt * 10)).reshape(nwt, 10)) dko = pd.DataFrame(np.array(random.choices('01', k = nko * 10)).reshape(nko, 10)) for i in np.arange(10): A = _get_father(nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = my_own_get_fitness, obj = 1) A.print() 110011000001000 ... 110011000001000 || 110011001111101 ... 111011110111010 5 17 1.0 111110000101011 ... 111110000101011 || 100110000001111 ... 011110100001011 9 11 1.0 010001110001001 ... 010001110001001 || 101010000001001 ... 010011011011110 6 12 1.0 100110001011100 ... 100110001011100 || 011111100111111 ... 111111101001100 7 17 1.0 111101110100010 ... 111101110100010 || 001000001001111 ... 011111011000001 9 10 1.0 001110011101011 ... 001110011101011 || 001110001101100 ... 011001000001110 9 11 1.0 100110010100001 ... 100110010100001 || 101011001110011 ... 100111110100001 6 14 1.0 101000101010110 ... 101000101010110 || 011110001000010 ... 000101001101101 7 12 1.0 101101000111111 ... 101101000111111 || 010001011010110 ... 101100011110110 10 13 1.0 100010011101000 ... 100010011101000 || 100000001100100 ... 001000101000100 6 7 1.0 Definition of a little more complex function # In this case, we considerer the following fitness function. def my_own_get_fitness(genes, nwt, nko, dwt, dko, obj): N_WT = sum(1 for x in genes[:nwt] if x == '1') N_KO = sum(1 for x in genes[nwt:] if x == '1') p = N_WT / N_KO return p nwt = 15 nko = 25 dwt = pd.DataFrame(np.array(random.choices('01', k = nwt * 10)).reshape(nwt, 10)) dko = pd.DataFrame(np.array(random.choices('01', k = nko * 10)).reshape(nko, 10)) for i in np.arange(10): A = _get_father(nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = my_own_get_fitness, obj = 1) A.print() 101101010001100 ... 101101010001100 || 001111100111000 ... 110001000000010 7 10 0.7 011111101110001 ... 011111101110001 || 101011110010001 ... 100010110010100 10 12 0.8333333333333334 100010101100111 ... 100010101100111 || 101011111110000 ... 100000101111010 8 15 0.5333333333333333 111111010110110 ... 111111010110110 || 100010110011100 ... 111001100100110 11 12 0.9166666666666666 110001100110000 ... 110001100110000 || 000001010000100 ... 001001111000011 6 9 0.6666666666666666 000110110000011 ... 000110110000011 || 001111111111110 ... 111100011000111 6 17 0.35294117647058826 011100100101000 ... 011100100101000 || 001000100101111 ... 011110110100010 6 11 0.5454545454545454 100111100010001 ... 100111100010001 || 101110000110001 ... 100011110010011 7 13 0.5384615384615384 101101100110001 ... 101101100110001 || 010100101010101 ... 101010110100011 8 12 0.6666666666666666 111110010111010 ... 111110010111010 || 100011110101101 ... 011011010000010 10 12 0.8333333333333334 It is easy to calculate the fitness function. For example, in the first solution the fitness value is 7/10 = 0.7. Using a fitness function with mutation operation to find an optimum # In this example, the optimum will be find when the genes string will be '111111...11111'. In this case, p = 0 def my_own_get_fitness(genes, nwt, nko, dwt, dko, obj): N_WT = sum(1 for x in genes[:nwt] if x == '1') - nwt N_KO = sum(1 for x in genes[nwt:] if x == '1') - nko p = N_WT + N_KO return p nwt = 15 nko = 25 dwt = pd.DataFrame(np.array(random.choices('01', k = nwt * 10)).reshape(nwt, 10)) dko = pd.DataFrame(np.array(random.choices('01', k = nko * 10)).reshape(nko, 10)) for i in np.arange(10): A = _get_father(nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = my_own_get_fitness, obj = 0) A.print() 101000001010000 ... 101000001010000 || 000001010101001 ... 010010010010010 4 8 -28 010001000011010 ... 010001000011010 || 111100010001000 ... 010001111001000 5 11 -24 110011100110111 ... 110011100110111 || 011111111100110 ... 001100110110011 10 17 -13 100111010100011 ... 100111010100011 || 001011100010000 ... 100001011100010 8 10 -22 110001110110110 ... 110001110110110 || 110011011101011 ... 010110111100110 9 16 -15 111000100101110 ... 111000100101110 || 011101011110100 ... 101001011011001 8 15 -17 100010000110110 ... 100010000110110 || 010010011000000 ... 000001011111001 6 11 -23 001110011110111 ... 001110011110111 || 100011011100010 ... 000101010110111 10 14 -16 101010101010011 ... 101010101010011 || 011110111100010 ... 000101100001100 8 13 -19 000001110111111 ... 000001110111111 || 011010000011111 ... 111110000000001 9 9 -22 We initialize the algorithm with a maximum of 1000 generations. When the iterations reached the 1000 iterations, the algorithm stops and returns the optimum reached. Moreover, in the following example, the _mutation function is applied. generations = 1000 starttime = datetime.datetime.now() nwt = 25 nko = 50 dwt = pd.DataFrame(np.array(random.choices('01', k = nwt * 20)).reshape(nwt, 20)) dko = pd.DataFrame(np.array(random.choices('01', k = nko * 20)).reshape(nko, 20)) A = _get_father(nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = my_own_get_fitness, obj = 0) for i in np.arange(generations): A_son = _mutation(A.Genes, geneSet = '01', get_fitness = my_own_get_fitness, nwt = nwt, nko = nko, dwt = dwt, dko = dko, obj = 0, type = 'bsm', p = None) if A_son.Fitness > A.Fitness: A = A_son _show_partial_solution(A, starttime = starttime, N = 4) 0101...1111 || 1010...0001 14 22 -39 time: 0.001 0101...1111 || 1110...0001 16 24 -35 time: 0.002 0101...1111 || 1110...0001 16 25 -34 time: 0.002 0101...1111 || 1110...0001 16 26 -33 time: 0.003 0101...1111 || 1110...0001 17 27 -31 time: 0.003 0101...1111 || 1110...0001 17 28 -30 time: 0.003 0101...1111 || 1110...0001 17 29 -29 time: 0.003 0101...1111 || 1110...0001 18 29 -28 time: 0.003 0101...1111 || 1110...0001 18 30 -27 time: 0.003 0101...1111 || 1110...0001 18 31 -26 time: 0.004 0101...1111 || 1110...0001 18 32 -25 time: 0.004 0101...1111 || 1110...0001 19 32 -24 time: 0.007 0101...1111 || 1110...0001 19 33 -23 time: 0.008 0101...1111 || 1110...0001 19 34 -22 time: 0.008 1101...1111 || 1110...0001 20 34 -21 time: 0.009 1101...1111 || 1110...0001 20 35 -20 time: 0.009 1101...1111 || 1110...0001 20 36 -19 time: 0.010 1101...1111 || 1110...0001 20 37 -18 time: 0.011 1101...1111 || 1110...0001 20 38 -17 time: 0.011 1101...1111 || 1110...0001 20 39 -16 time: 0.011 1101...1111 || 1110...0001 21 39 -15 time: 0.011 1101...1111 || 1110...0001 22 39 -14 time: 0.011 1101...1111 || 1110...0001 23 39 -13 time: 0.012 1101...1111 || 1110...0001 24 39 -12 time: 0.013 1101...1111 || 1110...0001 24 40 -11 time: 0.017 1101...1111 || 1110...0011 24 41 -10 time: 0.018 1101...1111 || 1111...0011 24 42 -9 time: 0.024 1111...1111 || 1111...0011 25 42 -8 time: 0.025 1111...1111 || 1111...0011 25 43 -7 time: 0.026 1111...1111 || 1111...0011 25 44 -6 time: 0.032 1111...1111 || 1111...0011 25 45 -5 time: 0.032 1111...1111 || 1111...1011 25 46 -4 time: 0.036 1111...1111 || 1111...1111 25 47 -3 time: 0.040 1111...1111 || 1111...1111 25 48 -2 time: 0.050 1111...1111 || 1111...1111 25 49 -1 time: 0.056 1111...1111 || 1111...1111 25 50 0 time: 0.056 We can see how the algorithm reaches the optimum at 0.056 seconds. import pandas as pd import numpy as np import matplotlib.pyplot as plt fig, ax = plt.subplots(nrows = 1, ncols = 1, figsize = (10, 6)) generations = 10000 starttime = datetime.datetime.now() nwt = 250 nko = 500 dwt = pd.DataFrame(np.array(random.choices('01', k = nwt * 50)).reshape(nwt, 50)) dko = pd.DataFrame(np.array(random.choices('01', k = nko * 50)).reshape(nko, 50)) for k in [1,2,3,4,5]: p = 10**(-k) results = [] starttime = datetime.datetime.now() A = _get_father(nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = my_own_get_fitness, obj = 0, random_state = 42) for i in np.arange(generations): A_son = _mutation(A.Genes, geneSet = '01', get_fitness = my_own_get_fitness, nwt = nwt, nko = nko, dwt = dwt, dko = dko, obj = 0, type = 'bsm', p = p) if A_son.Fitness > A.Fitness: A = A_son results.append([p, A.Fitness, (datetime.datetime.now() - starttime).total_seconds()]) results = pd.DataFrame(results, columns = ['p', 'fitness', 'time']) ax.plot(results.time, results.fitness, label = r'p = $10^{-{' + str(k) + '}}$', linewidth = 2) ax.grid(linestyle = '--', color = 'gray', alpha = 0.5) ax.set_title(r'Convergence of the genetic algorithm by mutation probability (10000 generations)') ax.set_ylabel(r'Fitness value') ax.set_xlabel(r'Time (seconds)') ax.legend(frameon = False, title = r'Probability', bbox_to_anchor = [1.0, 1.0]); ```{figure} example_files/example_20_0.png # alt: Example class: bg-primary width: 80% align: center name: example_time Evolution of fitness value of the genetic algorithms by different probability values of mutation. We can observe that the genetic algorithm with a probability of mutation of $10^{-3}$, reaches the optimum in 2.5 seconds. ## Chinese postman problem The Chinese postman problem, postman tour or route inspection problem is to find a shortest closed path or circuit that visits every edge of a (connected) undirected graph. When the graph has an Eulerian circuit (a closed walk that covers every edge once), that circuit is an optimal solution.[^wiki_chinese_problem] [^wiki_chinese_problem]: [Chinese Postman Problem](https://en.wikipedia.org/wiki/Route_inspection_problem) A simple example has been built with only four cities. The problem starts and finishes in the city **A**. In the following matrix the distances between each two cities is shown. ```{math} --- label: distances_chinese_problem --- \\begin{array}{cc} & \\begin{array}{cccc} \\quad A\\quad & B\\quad & C\\quad & D\\quad \\end{array} \\\\ \\begin{array}{c} A \\\\ B \\\\ C \\\\ D \\end{array} & \\left| \\begin{array}{cccc} 0.00 & 5.00 & 5.09 & 9.21\\\\ 5.00 & 0.00 & 2.23 & 2.42\\\\ 5.09 & 2.23 & 0.00 & 5.38\\\\ 9.21 & 2.42 & 5.38 & 0.00\\end{array} \\right| \\end{array} With these distances we can calculate the distance of each route. These distances are the fitness value for this genetic algorithm. --- label: fitness_chinese_problem --- f\\left\\{ \\left[\\begin{matrix} ABCDA \\\\ ABDCA \\\\ ACBDA \\\\ ACDBA \\\\ ADBCA \\\\ ADCBA \\end{matrix} \\right] \\right\\} = \\left[ \\begin{matrix} 21.82 \\\\ 19.71 \\\\ 20.77 \\\\ 19.71 \\\\ 20.77 \\\\ 21.82 \\end{matrix} \\right] ```{code-cell} ipython3 # tags: [remove-cell] # import pandas as pd import matplotlib.pyplot as plt from myst_nb import glue ```{code-cell} ipython3 --- tags: [remove-cell] --- for row_, fv, ruta in zip(range(6), (21.82, 19.71, 20.77, 19.71, 20.77, 21.82), ('ABCDA', 'ABDCA', 'ACBDA', 'ACDBA', 'ADBCA', 'ADCBA')): fig, ax = plt.subplots(nrows = 1, ncols = 1, figsize = (3,2)) data = pd.DataFrame([[0,0], [3,4], [1,5], [6,7]], columns = list('XY'), index = list('ABCD')) data = pd.DataFrame([[0,3,1,6], [0,4,5,7]], columns = list('ABCD'), index = list('XY')) data.T.plot(kind = 'scatter', x = 'X', y = 'Y', ax = ax, s = 75) paso = 0.3 ax.annotate('A', (0, 0 + paso), fontsize = 14) ax.annotate('B', (3, 4 + paso), fontsize = 14) ax.annotate('C', (1, 5 + paso), fontsize = 14) ax.annotate('D', (6, 7 + paso), fontsize = 14) data_pt = pd.DataFrame([ [(0,1),(1,2),(2,3),(3,0)], [(0,1),(1,3),(3,2),(2,0)], [(0,2),(2,1),(1,3),(3,0)], [(0,2),(2,3),(3,1),(1,0)], [(0,3),(3,1),(1,2),(2,0)], [(0,3),(3,2),(2,1),(1,0)]]) for column_ in range(4): point_x = data.iloc[:, data_pt.iloc[row_][column_][0]].values point_y = data.iloc[:, data_pt.iloc[row_][column_][1]].values ax.annotate(\"\", xy = (point_y[0], point_y[1]), xycoords = 'data', xytext = (point_x[0], point_x[1]), textcoords='data', arrowprops = dict(arrowstyle = \"->\", shrinkA = 10, shrinkB = 10, connectionstyle = \"arc3\")) ax.set_xlabel('') ax.set_ylabel('') ax.grid(linestyle = ':', color = 'gray') glue(ruta, fig, display = False) The genotype space (see {ref} genotype_interpretation for more information) for this problem is composed for only six chromosomes (table {ref} table_genotype_space ). ``{table} Genotype space and fitness value for each solution. The routes are shown in lexicographic order. :align: center :width: 80% :name: table_genotype_space | Genotypes | Distance | Route | Fitness | |:-:|:-:|:-:|:-:| | ABCDA | 5.00 + 2.23 + 5.38 + 9.21 | {glue:} ABCDA | 21.82 | | ABDCA | 5.00 + 4.24 + 5.38 + 5.09 | {glue:} ABDCA | 19.71 | | ACBDA | 5.09 + 2.23 + 4.24 + 9.21 | {glue:} ACBDA | 20.77 | | ACDBA | 5.09 + 5.38 + 4.24 + 5.00 | {glue:} ACDBA | 19.71 | | ADBCA | 9.21 + 4.24 + 2.23 + 5.09 | {glue:} ADBCA | 20.77 | | ADCBA | 9.21 + 5.38 + 2.23 + 5.00 | {glue:} ADCBA` | 21.82 | We can conclude that the optimum solution is ABDCA and ACDBA. In the figure {figure:numref}`figure_routes_chinese_postman` we can see the phenotype space. ```{code-cell} ipython3 --- tags: [remove-cell] --- fig, axes = plt.subplots(nrows = 3, ncols = 2, figsize = (14,12)) data = pd.DataFrame([[0,0], [3,4], [1,5], [6,7]], columns = list('XY'), index = list('ABCD')) data = pd.DataFrame([[0,3,1,6], [0,4,5,7]], columns = list('ABCD'), index = list('XY')) for ax, row_, fv in zip(axes.flat, range(6), (21.82, 19.71, 20.77, 19.71, 20.77, 21.82)): data.T.plot(kind = 'scatter', x = 'X', y = 'Y', ax = ax, s = 75) paso = 0.3 ax.annotate('A', (0, 0 + paso), fontsize = 14) ax.annotate('B', (3, 4 + paso), fontsize = 14) ax.annotate('C', (1, 5 + paso), fontsize = 14) ax.annotate('D', (6, 7 + paso), fontsize = 14) data_pt = pd.DataFrame([ [(0,1),(1,2),(2,3),(3,0)], [(0,1),(1,3),(3,2),(2,0)], [(0,2),(2,1),(1,3),(3,0)], [(0,2),(2,3),(3,1),(1,0)], [(0,3),(3,1),(1,2),(2,0)], [(0,3),(3,2),(2,1),(1,0)]]) for column_ in range(4): point_x = data.iloc[:, data_pt.iloc[row_][column_][0]].values point_y = data.iloc[:, data_pt.iloc[row_][column_][1]].values #ax.plot((point_x[0], point_y[0]), (point_x[1],point_y[1]), color = 'black') ax.annotate(\"\", xy = (point_y[0], point_y[1]), xycoords = 'data', xytext = (point_x[0], point_x[1]), textcoords='data', arrowprops = dict(arrowstyle = \"->\", shrinkA = 10, shrinkB = 10, connectionstyle = \"arc3\")) #data.T.plot(kind = 'scatter', x = 'X', y = 'Y', ax = ax, s = 100) titulo = '' for column_ in range(4): titulo = titulo + ' | ' + data.columns[data_pt.iloc[row_][column_][0]] + ' -> ' + data.columns[data_pt.iloc[row_][column_][1]] titulo = titulo + ' |\\n' + 'fitness: ' + str(fv) ax.set_title(titulo) ax.set_xlabel('') ax.set_ylabel('') ax.grid(linestyle = ':', color = 'gray') fig.subplots_adjust(wspace = 0.10, hspace = 0.35) glue(\"glue_routes_chinese_postman_problem\", fig, display = False) ```{glue:figure} glue_routes_chinese_postman_problem # align: center name: figure_routes_chinese_postman All possibles routes among the four cities with the city A as node. These routes are the phenotype space for this problem. ```","title":"Examples"},{"location":"package/package/examples.html#examples","text":"Import the pygenmet package from pygenmet import * import pandas as pd import numpy as np import random import datetime We define a new fitness function.","title":"Examples"},{"location":"package/package/examples.html#definition_of_a_simple_fitness_function","text":"We define a simple fitness function. This function always returns the 1.0 value. def my_own_get_fitness(genes, nwt, nko, dwt, dko, obj): p = 1.0 return p Now, we generate 10 initial solutions (by _get_father_ function) and we can see the fitness function for each solution. nwt = 15 nko = 25 dwt = pd.DataFrame(np.array(random.choices('01', k = nwt * 10)).reshape(nwt, 10)) dko = pd.DataFrame(np.array(random.choices('01', k = nko * 10)).reshape(nko, 10)) for i in np.arange(10): A = _get_father(nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = my_own_get_fitness, obj = 1) A.print() 110011000001000 ... 110011000001000 || 110011001111101 ... 111011110111010 5 17 1.0 111110000101011 ... 111110000101011 || 100110000001111 ... 011110100001011 9 11 1.0 010001110001001 ... 010001110001001 || 101010000001001 ... 010011011011110 6 12 1.0 100110001011100 ... 100110001011100 || 011111100111111 ... 111111101001100 7 17 1.0 111101110100010 ... 111101110100010 || 001000001001111 ... 011111011000001 9 10 1.0 001110011101011 ... 001110011101011 || 001110001101100 ... 011001000001110 9 11 1.0 100110010100001 ... 100110010100001 || 101011001110011 ... 100111110100001 6 14 1.0 101000101010110 ... 101000101010110 || 011110001000010 ... 000101001101101 7 12 1.0 101101000111111 ... 101101000111111 || 010001011010110 ... 101100011110110 10 13 1.0 100010011101000 ... 100010011101000 || 100000001100100 ... 001000101000100 6 7 1.0","title":"Definition of a simple fitness function"},{"location":"package/package/examples.html#definition_of_a_little_more_complex_function","text":"In this case, we considerer the following fitness function. def my_own_get_fitness(genes, nwt, nko, dwt, dko, obj): N_WT = sum(1 for x in genes[:nwt] if x == '1') N_KO = sum(1 for x in genes[nwt:] if x == '1') p = N_WT / N_KO return p nwt = 15 nko = 25 dwt = pd.DataFrame(np.array(random.choices('01', k = nwt * 10)).reshape(nwt, 10)) dko = pd.DataFrame(np.array(random.choices('01', k = nko * 10)).reshape(nko, 10)) for i in np.arange(10): A = _get_father(nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = my_own_get_fitness, obj = 1) A.print() 101101010001100 ... 101101010001100 || 001111100111000 ... 110001000000010 7 10 0.7 011111101110001 ... 011111101110001 || 101011110010001 ... 100010110010100 10 12 0.8333333333333334 100010101100111 ... 100010101100111 || 101011111110000 ... 100000101111010 8 15 0.5333333333333333 111111010110110 ... 111111010110110 || 100010110011100 ... 111001100100110 11 12 0.9166666666666666 110001100110000 ... 110001100110000 || 000001010000100 ... 001001111000011 6 9 0.6666666666666666 000110110000011 ... 000110110000011 || 001111111111110 ... 111100011000111 6 17 0.35294117647058826 011100100101000 ... 011100100101000 || 001000100101111 ... 011110110100010 6 11 0.5454545454545454 100111100010001 ... 100111100010001 || 101110000110001 ... 100011110010011 7 13 0.5384615384615384 101101100110001 ... 101101100110001 || 010100101010101 ... 101010110100011 8 12 0.6666666666666666 111110010111010 ... 111110010111010 || 100011110101101 ... 011011010000010 10 12 0.8333333333333334 It is easy to calculate the fitness function. For example, in the first solution the fitness value is 7/10 = 0.7.","title":"Definition of a little more complex function"},{"location":"package/package/examples.html#using_a_fitness_function_with_mutation_operation_to_find_an_optimum","text":"In this example, the optimum will be find when the genes string will be '111111...11111'. In this case, p = 0 def my_own_get_fitness(genes, nwt, nko, dwt, dko, obj): N_WT = sum(1 for x in genes[:nwt] if x == '1') - nwt N_KO = sum(1 for x in genes[nwt:] if x == '1') - nko p = N_WT + N_KO return p nwt = 15 nko = 25 dwt = pd.DataFrame(np.array(random.choices('01', k = nwt * 10)).reshape(nwt, 10)) dko = pd.DataFrame(np.array(random.choices('01', k = nko * 10)).reshape(nko, 10)) for i in np.arange(10): A = _get_father(nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = my_own_get_fitness, obj = 0) A.print() 101000001010000 ... 101000001010000 || 000001010101001 ... 010010010010010 4 8 -28 010001000011010 ... 010001000011010 || 111100010001000 ... 010001111001000 5 11 -24 110011100110111 ... 110011100110111 || 011111111100110 ... 001100110110011 10 17 -13 100111010100011 ... 100111010100011 || 001011100010000 ... 100001011100010 8 10 -22 110001110110110 ... 110001110110110 || 110011011101011 ... 010110111100110 9 16 -15 111000100101110 ... 111000100101110 || 011101011110100 ... 101001011011001 8 15 -17 100010000110110 ... 100010000110110 || 010010011000000 ... 000001011111001 6 11 -23 001110011110111 ... 001110011110111 || 100011011100010 ... 000101010110111 10 14 -16 101010101010011 ... 101010101010011 || 011110111100010 ... 000101100001100 8 13 -19 000001110111111 ... 000001110111111 || 011010000011111 ... 111110000000001 9 9 -22 We initialize the algorithm with a maximum of 1000 generations. When the iterations reached the 1000 iterations, the algorithm stops and returns the optimum reached. Moreover, in the following example, the _mutation function is applied. generations = 1000 starttime = datetime.datetime.now() nwt = 25 nko = 50 dwt = pd.DataFrame(np.array(random.choices('01', k = nwt * 20)).reshape(nwt, 20)) dko = pd.DataFrame(np.array(random.choices('01', k = nko * 20)).reshape(nko, 20)) A = _get_father(nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = my_own_get_fitness, obj = 0) for i in np.arange(generations): A_son = _mutation(A.Genes, geneSet = '01', get_fitness = my_own_get_fitness, nwt = nwt, nko = nko, dwt = dwt, dko = dko, obj = 0, type = 'bsm', p = None) if A_son.Fitness > A.Fitness: A = A_son _show_partial_solution(A, starttime = starttime, N = 4) 0101...1111 || 1010...0001 14 22 -39 time: 0.001 0101...1111 || 1110...0001 16 24 -35 time: 0.002 0101...1111 || 1110...0001 16 25 -34 time: 0.002 0101...1111 || 1110...0001 16 26 -33 time: 0.003 0101...1111 || 1110...0001 17 27 -31 time: 0.003 0101...1111 || 1110...0001 17 28 -30 time: 0.003 0101...1111 || 1110...0001 17 29 -29 time: 0.003 0101...1111 || 1110...0001 18 29 -28 time: 0.003 0101...1111 || 1110...0001 18 30 -27 time: 0.003 0101...1111 || 1110...0001 18 31 -26 time: 0.004 0101...1111 || 1110...0001 18 32 -25 time: 0.004 0101...1111 || 1110...0001 19 32 -24 time: 0.007 0101...1111 || 1110...0001 19 33 -23 time: 0.008 0101...1111 || 1110...0001 19 34 -22 time: 0.008 1101...1111 || 1110...0001 20 34 -21 time: 0.009 1101...1111 || 1110...0001 20 35 -20 time: 0.009 1101...1111 || 1110...0001 20 36 -19 time: 0.010 1101...1111 || 1110...0001 20 37 -18 time: 0.011 1101...1111 || 1110...0001 20 38 -17 time: 0.011 1101...1111 || 1110...0001 20 39 -16 time: 0.011 1101...1111 || 1110...0001 21 39 -15 time: 0.011 1101...1111 || 1110...0001 22 39 -14 time: 0.011 1101...1111 || 1110...0001 23 39 -13 time: 0.012 1101...1111 || 1110...0001 24 39 -12 time: 0.013 1101...1111 || 1110...0001 24 40 -11 time: 0.017 1101...1111 || 1110...0011 24 41 -10 time: 0.018 1101...1111 || 1111...0011 24 42 -9 time: 0.024 1111...1111 || 1111...0011 25 42 -8 time: 0.025 1111...1111 || 1111...0011 25 43 -7 time: 0.026 1111...1111 || 1111...0011 25 44 -6 time: 0.032 1111...1111 || 1111...0011 25 45 -5 time: 0.032 1111...1111 || 1111...1011 25 46 -4 time: 0.036 1111...1111 || 1111...1111 25 47 -3 time: 0.040 1111...1111 || 1111...1111 25 48 -2 time: 0.050 1111...1111 || 1111...1111 25 49 -1 time: 0.056 1111...1111 || 1111...1111 25 50 0 time: 0.056 We can see how the algorithm reaches the optimum at 0.056 seconds. import pandas as pd import numpy as np import matplotlib.pyplot as plt fig, ax = plt.subplots(nrows = 1, ncols = 1, figsize = (10, 6)) generations = 10000 starttime = datetime.datetime.now() nwt = 250 nko = 500 dwt = pd.DataFrame(np.array(random.choices('01', k = nwt * 50)).reshape(nwt, 50)) dko = pd.DataFrame(np.array(random.choices('01', k = nko * 50)).reshape(nko, 50)) for k in [1,2,3,4,5]: p = 10**(-k) results = [] starttime = datetime.datetime.now() A = _get_father(nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = my_own_get_fitness, obj = 0, random_state = 42) for i in np.arange(generations): A_son = _mutation(A.Genes, geneSet = '01', get_fitness = my_own_get_fitness, nwt = nwt, nko = nko, dwt = dwt, dko = dko, obj = 0, type = 'bsm', p = p) if A_son.Fitness > A.Fitness: A = A_son results.append([p, A.Fitness, (datetime.datetime.now() - starttime).total_seconds()]) results = pd.DataFrame(results, columns = ['p', 'fitness', 'time']) ax.plot(results.time, results.fitness, label = r'p = $10^{-{' + str(k) + '}}$', linewidth = 2) ax.grid(linestyle = '--', color = 'gray', alpha = 0.5) ax.set_title(r'Convergence of the genetic algorithm by mutation probability (10000 generations)') ax.set_ylabel(r'Fitness value') ax.set_xlabel(r'Time (seconds)') ax.legend(frameon = False, title = r'Probability', bbox_to_anchor = [1.0, 1.0]);","title":"Using a fitness function with mutation operation to find an optimum"},{"location":"package/package/examples.html#figure_example_filesexample_20_0png","text":"alt: Example class: bg-primary width: 80% align: center name: example_time Evolution of fitness value of the genetic algorithms by different probability values of mutation. We can observe that the genetic algorithm with a probability of mutation of $10^{-3}$, reaches the optimum in 2.5 seconds. ## Chinese postman problem The Chinese postman problem, postman tour or route inspection problem is to find a shortest closed path or circuit that visits every edge of a (connected) undirected graph. When the graph has an Eulerian circuit (a closed walk that covers every edge once), that circuit is an optimal solution.[^wiki_chinese_problem] [^wiki_chinese_problem]: [Chinese Postman Problem](https://en.wikipedia.org/wiki/Route_inspection_problem) A simple example has been built with only four cities. The problem starts and finishes in the city **A**. In the following matrix the distances between each two cities is shown. ```{math} --- label: distances_chinese_problem --- \\begin{array}{cc} & \\begin{array}{cccc} \\quad A\\quad & B\\quad & C\\quad & D\\quad \\end{array} \\\\ \\begin{array}{c} A \\\\ B \\\\ C \\\\ D \\end{array} & \\left| \\begin{array}{cccc} 0.00 & 5.00 & 5.09 & 9.21\\\\ 5.00 & 0.00 & 2.23 & 2.42\\\\ 5.09 & 2.23 & 0.00 & 5.38\\\\ 9.21 & 2.42 & 5.38 & 0.00\\end{array} \\right| \\end{array} With these distances we can calculate the distance of each route. These distances are the fitness value for this genetic algorithm. --- label: fitness_chinese_problem --- f\\left\\{ \\left[\\begin{matrix} ABCDA \\\\ ABDCA \\\\ ACBDA \\\\ ACDBA \\\\ ADBCA \\\\ ADCBA \\end{matrix} \\right] \\right\\} = \\left[ \\begin{matrix} 21.82 \\\\ 19.71 \\\\ 20.77 \\\\ 19.71 \\\\ 20.77 \\\\ 21.82 \\end{matrix} \\right]","title":"```{figure} example_files/example_20_0.png"},{"location":"package/package/examples.html#code-cell_ipython3","text":"","title":"```{code-cell} ipython3"},{"location":"package/package/examples.html#tags_remove-cell","text":"import pandas as pd import matplotlib.pyplot as plt from myst_nb import glue ```{code-cell} ipython3 --- tags: [remove-cell] --- for row_, fv, ruta in zip(range(6), (21.82, 19.71, 20.77, 19.71, 20.77, 21.82), ('ABCDA', 'ABDCA', 'ACBDA', 'ACDBA', 'ADBCA', 'ADCBA')): fig, ax = plt.subplots(nrows = 1, ncols = 1, figsize = (3,2)) data = pd.DataFrame([[0,0], [3,4], [1,5], [6,7]], columns = list('XY'), index = list('ABCD')) data = pd.DataFrame([[0,3,1,6], [0,4,5,7]], columns = list('ABCD'), index = list('XY')) data.T.plot(kind = 'scatter', x = 'X', y = 'Y', ax = ax, s = 75) paso = 0.3 ax.annotate('A', (0, 0 + paso), fontsize = 14) ax.annotate('B', (3, 4 + paso), fontsize = 14) ax.annotate('C', (1, 5 + paso), fontsize = 14) ax.annotate('D', (6, 7 + paso), fontsize = 14) data_pt = pd.DataFrame([ [(0,1),(1,2),(2,3),(3,0)], [(0,1),(1,3),(3,2),(2,0)], [(0,2),(2,1),(1,3),(3,0)], [(0,2),(2,3),(3,1),(1,0)], [(0,3),(3,1),(1,2),(2,0)], [(0,3),(3,2),(2,1),(1,0)]]) for column_ in range(4): point_x = data.iloc[:, data_pt.iloc[row_][column_][0]].values point_y = data.iloc[:, data_pt.iloc[row_][column_][1]].values ax.annotate(\"\", xy = (point_y[0], point_y[1]), xycoords = 'data', xytext = (point_x[0], point_x[1]), textcoords='data', arrowprops = dict(arrowstyle = \"->\", shrinkA = 10, shrinkB = 10, connectionstyle = \"arc3\")) ax.set_xlabel('') ax.set_ylabel('') ax.grid(linestyle = ':', color = 'gray') glue(ruta, fig, display = False) The genotype space (see {ref} genotype_interpretation for more information) for this problem is composed for only six chromosomes (table {ref} table_genotype_space ). ``{table} Genotype space and fitness value for each solution. The routes are shown in lexicographic order. :align: center :width: 80% :name: table_genotype_space | Genotypes | Distance | Route | Fitness | |:-:|:-:|:-:|:-:| | ABCDA | 5.00 + 2.23 + 5.38 + 9.21 | {glue:} ABCDA | 21.82 | | ABDCA | 5.00 + 4.24 + 5.38 + 5.09 | {glue:} ABDCA | 19.71 | | ACBDA | 5.09 + 2.23 + 4.24 + 9.21 | {glue:} ACBDA | 20.77 | | ACDBA | 5.09 + 5.38 + 4.24 + 5.00 | {glue:} ACDBA | 19.71 | | ADBCA | 9.21 + 4.24 + 2.23 + 5.09 | {glue:} ADBCA | 20.77 | | ADCBA | 9.21 + 5.38 + 2.23 + 5.00 | {glue:} ADCBA` | 21.82 | We can conclude that the optimum solution is ABDCA and ACDBA. In the figure {figure:numref}`figure_routes_chinese_postman` we can see the phenotype space. ```{code-cell} ipython3 --- tags: [remove-cell] --- fig, axes = plt.subplots(nrows = 3, ncols = 2, figsize = (14,12)) data = pd.DataFrame([[0,0], [3,4], [1,5], [6,7]], columns = list('XY'), index = list('ABCD')) data = pd.DataFrame([[0,3,1,6], [0,4,5,7]], columns = list('ABCD'), index = list('XY')) for ax, row_, fv in zip(axes.flat, range(6), (21.82, 19.71, 20.77, 19.71, 20.77, 21.82)): data.T.plot(kind = 'scatter', x = 'X', y = 'Y', ax = ax, s = 75) paso = 0.3 ax.annotate('A', (0, 0 + paso), fontsize = 14) ax.annotate('B', (3, 4 + paso), fontsize = 14) ax.annotate('C', (1, 5 + paso), fontsize = 14) ax.annotate('D', (6, 7 + paso), fontsize = 14) data_pt = pd.DataFrame([ [(0,1),(1,2),(2,3),(3,0)], [(0,1),(1,3),(3,2),(2,0)], [(0,2),(2,1),(1,3),(3,0)], [(0,2),(2,3),(3,1),(1,0)], [(0,3),(3,1),(1,2),(2,0)], [(0,3),(3,2),(2,1),(1,0)]]) for column_ in range(4): point_x = data.iloc[:, data_pt.iloc[row_][column_][0]].values point_y = data.iloc[:, data_pt.iloc[row_][column_][1]].values #ax.plot((point_x[0], point_y[0]), (point_x[1],point_y[1]), color = 'black') ax.annotate(\"\", xy = (point_y[0], point_y[1]), xycoords = 'data', xytext = (point_x[0], point_x[1]), textcoords='data', arrowprops = dict(arrowstyle = \"->\", shrinkA = 10, shrinkB = 10, connectionstyle = \"arc3\")) #data.T.plot(kind = 'scatter', x = 'X', y = 'Y', ax = ax, s = 100) titulo = '' for column_ in range(4): titulo = titulo + ' | ' + data.columns[data_pt.iloc[row_][column_][0]] + ' -> ' + data.columns[data_pt.iloc[row_][column_][1]] titulo = titulo + ' |\\n' + 'fitness: ' + str(fv) ax.set_title(titulo) ax.set_xlabel('') ax.set_ylabel('') ax.grid(linestyle = ':', color = 'gray') fig.subplots_adjust(wspace = 0.10, hspace = 0.35) glue(\"glue_routes_chinese_postman_problem\", fig, display = False)","title":"tags: [remove-cell]"},{"location":"package/package/examples.html#gluefigure_glue_routes_chinese_postman_problem","text":"align: center name: figure_routes_chinese_postman All possibles routes among the four cities with the city A as node. These routes are the phenotype space for this problem. ```","title":"```{glue:figure} glue_routes_chinese_postman_problem"},{"location":"package/package/fitness.html","text":"Fitness # Import the pygenmet package from pygenmet import * Currently, three fully customizable fitness functions are developed in pygenmet package: _get_fitness _get_fitness_robust _get_fitness_l fitness._get_fitness # The docstring associated to the _get_fitness function is the following. ?_get_fitness Parameters ---------- genes : Genes of a chromosome nwt : Number of observations of Wild Type nko : Number of observations of Knock-out dwt : Data of observations of Wild Type dko : Data of observations of Knock-out obj : Array of fold-changes of metabolites in murine model l : float Usually 0.5 / length(fc1). If length(fc1) = 50 then l = 0.01 Returns ------- p : float The aptitude of a genes of a chromosome (solution) is the correlation between fc1 and fc2. Initially the aptitude (fitness) of a chromosome is the Pearson Correlation between the fold-change of Knock-out select samples and Wild Type selected samples with the fold-change of the murine model analyzed (a vector of \u00bf50? fold-changes). Notes ----- This function evaluates the Pearson Correlation between fc1 and fc2 with a penalty for different sign in the values. This function uses pearsonr from scipy and sign from numpy to evaluate the aptitude. The penalty has been named l. Examples -------- fitness._get_fitness_robust # The docstring associated to the _get_fitness_robust function is the following. ?_get_fitness_robust Parameters ---------- genes : Genes of a chromosome nwt : Number of observations of Wild Type nko : Number of observations of Knock-out dwt : Data of observations of Wild Type dko : Data of observations of Knock-out obj : Array of fold-changes of metabolites in murine model l : float Usually 0.5 / length(fc1). If length(fc1) = 50 then l = 0.01 Returns ------- p : float The aptitude of a genes of a chromosome (solution) is the correlation between fc1 and fc2. Initially the aptitude (fitness) of a chromosome is the Pearson Correlation between the fold-change of Knock-out select samples and Wild Type selected samples with the fold-change of the murine model analyzed (a vector of \u00bf50? fold-changes). Notes ----- This function evaluates the Pearson Correlation between fc1 and fc2 with a penalty for different sign in the values. This function uses pearsonr from scipy and sign from numpy to evaluate the aptitude. The penalty has been named l. Examples -------- fitness._get_fitness_l # The docstring associated to the _get_fitness_l function is the following. ?_get_fitness_l Parameters ---------- genes : Genes of a chromosome nwt : Number of observations of Wild Type nko : Number of observations of Knock-out dwt : Data of observations of Wild Type dko : Data of observations of Knock-out obj : Array of fold-changes of metabolites in murine model Returns ------- p : float The aptitude of a genes of a chromosome (solution) is the correlation between fc1 and fc2. Initially the aptitude (fitness) of a chromosome is the Pearson Correlation between the fold-change of Knock-out select samples and Wild Type selected samples with the fold-change of the murine model analyzed (a vector of \u00bf50? fold-changes). Notes ----- This function evaluates the Pearson Correlation between fc1 and fc2 with a penalty for different sign in the values. This function uses pearsonr from scipy and sign from numpy to evaluate the aptitude. The penalty has been named l. Examples --------","title":"Fitness"},{"location":"package/package/fitness.html#fitness","text":"Import the pygenmet package from pygenmet import * Currently, three fully customizable fitness functions are developed in pygenmet package: _get_fitness _get_fitness_robust _get_fitness_l","title":"Fitness"},{"location":"package/package/fitness.html#fitness_get_fitness","text":"The docstring associated to the _get_fitness function is the following. ?_get_fitness Parameters ---------- genes : Genes of a chromosome nwt : Number of observations of Wild Type nko : Number of observations of Knock-out dwt : Data of observations of Wild Type dko : Data of observations of Knock-out obj : Array of fold-changes of metabolites in murine model l : float Usually 0.5 / length(fc1). If length(fc1) = 50 then l = 0.01 Returns ------- p : float The aptitude of a genes of a chromosome (solution) is the correlation between fc1 and fc2. Initially the aptitude (fitness) of a chromosome is the Pearson Correlation between the fold-change of Knock-out select samples and Wild Type selected samples with the fold-change of the murine model analyzed (a vector of \u00bf50? fold-changes). Notes ----- This function evaluates the Pearson Correlation between fc1 and fc2 with a penalty for different sign in the values. This function uses pearsonr from scipy and sign from numpy to evaluate the aptitude. The penalty has been named l. Examples --------","title":"fitness._get_fitness"},{"location":"package/package/fitness.html#fitness_get_fitness_robust","text":"The docstring associated to the _get_fitness_robust function is the following. ?_get_fitness_robust Parameters ---------- genes : Genes of a chromosome nwt : Number of observations of Wild Type nko : Number of observations of Knock-out dwt : Data of observations of Wild Type dko : Data of observations of Knock-out obj : Array of fold-changes of metabolites in murine model l : float Usually 0.5 / length(fc1). If length(fc1) = 50 then l = 0.01 Returns ------- p : float The aptitude of a genes of a chromosome (solution) is the correlation between fc1 and fc2. Initially the aptitude (fitness) of a chromosome is the Pearson Correlation between the fold-change of Knock-out select samples and Wild Type selected samples with the fold-change of the murine model analyzed (a vector of \u00bf50? fold-changes). Notes ----- This function evaluates the Pearson Correlation between fc1 and fc2 with a penalty for different sign in the values. This function uses pearsonr from scipy and sign from numpy to evaluate the aptitude. The penalty has been named l. Examples --------","title":"fitness._get_fitness_robust"},{"location":"package/package/fitness.html#fitness_get_fitness_l","text":"The docstring associated to the _get_fitness_l function is the following. ?_get_fitness_l Parameters ---------- genes : Genes of a chromosome nwt : Number of observations of Wild Type nko : Number of observations of Knock-out dwt : Data of observations of Wild Type dko : Data of observations of Knock-out obj : Array of fold-changes of metabolites in murine model Returns ------- p : float The aptitude of a genes of a chromosome (solution) is the correlation between fc1 and fc2. Initially the aptitude (fitness) of a chromosome is the Pearson Correlation between the fold-change of Knock-out select samples and Wild Type selected samples with the fold-change of the murine model analyzed (a vector of \u00bf50? fold-changes). Notes ----- This function evaluates the Pearson Correlation between fc1 and fc2 with a penalty for different sign in the values. This function uses pearsonr from scipy and sign from numpy to evaluate the aptitude. The penalty has been named l. Examples --------","title":"fitness._get_fitness_l"},{"location":"package/package/operators.html","text":"Operators # Import the pygenmet package from ..tools.tools import chromosome import pandas as pd import numpy as np Crossover # In Genetic Algorithms the crossover (also called recombination) is a genetic operator used to combine the genetic information of two parents to generate new offspring. operators._crossover # The docstring associated to the _crossover function is the following. ?_crossover Parameters ---------- chromosome_a: Chromosome chromosome_b: Chromosome k: k-point. If k = 1 the method will be single-point crossover, If k = 2 the method will be two-point crossover. If k = N (with N the length of chromosome) the method will be the uniform crossover. Its value is 1 by default. Returns ------- Two new chromosomes Notes ----- [1] References ---------- [1] https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm) Examples -------- >>> A = _get_father(nwt = dwt.shape[0], nko = dko.shape[0], dwt = dwt, dko = dko, geneSet = '01', get_fitness = _get_fitness, obj = np.array(FC.loc[:, murine_models_in[4]])) >>> B = _get_father(nwt = dwt.shape[0], nko = dko.shape[0], dwt = dwt, dko = dko, geneSet = '01', get_fitness = _get_fitness, obj = np.array(FC.loc[:, murine_models_in[4]])) >>> A.print() 011000111111010 ... 001000010001110 || 001010011000110 ... 011001001111111 43 336 0.03363686825576087 >>> B.print() 100101111101111 ... 010001000100101 || 010101001001010 ... 111010000101010 42 345 0.1410663212679354 >>> A1, B1 = _crossover(A, B, get_fitness = _get_fitness, nwt = dwt.shape[0], nko = dko.shape[0], dwt = dwt, dko = dko, obj = np.array(FC.loc[:, murine_models_in[4]]), k = 1) >>> A1.print() 011000111111010 ... 001000010001110 || 001010011000110 ... 111010000101010 43 327 0.007288743389698732 >>> B1.print() 100101111101111 ... 010001000100101 || 010101001001010 ... 011001001111111 42 354 0.15370276754212897 >>> A1, B1 = _crossover(A, B, get_fitness = _get_fitness, nwt = dwt.shape[0], nko = dko.shape[0], dwt = dwt, dko = dko, obj = np.array(FC.loc[:, murine_models_in[4]]), k = 772) >>> A1.print() 110000111101111 ... 000000010001111 || 011111001001110 ... 011000001111111 43 355 0.017131591198246282 >>> B1.print() 001101111111010 ... 011001000100100 || 000000011000010 ... 111011000101010 42 326 0.13633106854522628 operators._arithmetic_crossover # ?_arithmetic_crossover Notes ----- For this specific genotype (GeneSet = '01') the arithmetic crossover techniques are available. These techniques are: [1] AND [2] OR [3] XOR Arithmetic crossover - some arithmetic operation is performed to make a new offspring [1] References ---------- [1] https://www.obitko.com/tutorials/genetic-algorithms/crossover-mutation.php ```{table} Truth table for AND, OR and XOR logical operators. :align: center :width: 80% :name: truth_table | A | B | AND | OR | XOR | |:-:|:-:|:-:|:-:|:-:| | 0 | 0 | 0 | 0 | 0 | | 0 | 1 | 0 | 1 | 1 | | 1 | 0 | 0 | 1 | 1 | | 1 | 1 | 1 | 1 | 0 | ## Mutation See {ref}`theory:mutation` for the theory and definitions. ### operators.\\_mutation ```python ?_mutation Parameters ---------- father : Genes of the father geneSet : Set of genes availables. Usually '0' and '1' get_fitness : Function to improve nwt : Number of No NAFLD Samples nko : Number of NAFLD Samples dwt : Data of No NAFLD Samples dko : Data of NAFLD Samples obj : The fold-changes of murine model to adjust type : Type of mutation process, 'bsm' by default. Five types are allowed. bf : bitflip bsm : bitstringmutation sw : swap in : inversion sc : scramble p : Parameter to modify the posibility of change in a genes Returns ------- A new mutated chromosome by the type of mutation process Notes ----- The flipbit (fb) mutation is an aggressive mutation because change all genes. If in a specific gen the allelo value is '0' this process will change it to '1'. fb: '0101010101' -> '1010101010' The bitstringmutation (bsm) mutation process will change a gen with a probability 'p'. If p = None then p = 1/len(genes) [1]. bsm: '0101010101' -> '0101110101' References ---------- [1] https://en.wikipedia.org/wiki/Mutation_(genetic_algorithm) [2] https://www.tutorialspoint.com/genetic_algorithms/genetic_algorithms_mutation.htm Examples -------- Selection # operators._replacement # ?_replacement Parameters ---------- type : Type of replacement rws : Replace Worst Strategy rts : Restricted Tournament Selection wams : Worst Among Most Similar Replacement Notes ----- The _replacement function is ised to change the old generation population with the new generation. Four process have been evaluated [1]: 1) Replace Worst Strategy (RW). The worst element of the population is replaced if the child improves it. It offers high selective pressure, even when its parents are chosen randomly. 2) Restricted Tournament Selection (RTS) [2]. 3) Replace the Worst Among Most Similar Replacement (WAMS) [3]. the worst chromosome of the set of the N (N = 3,...) parents most similar to the offspring. 4) Deterministic Crowding Algorithm (Deterministic Crowding, DC) [4]. To facilitate the comparison we will use in our experiments. A variant of the DC in which a single descendant will be generated for each cross, which will replace the most similar parent if it improves it. References ---------- [1] https://sci2s.ugr.es/keel/pdf/keel/congreso/4-diversidadfinal2_daniel_molina.pdf [2] G. Harik. Finding multimodal solutions using restricted tournament selection. Proc. 6th Int. Conf. Genetic Algorithms, p\u00e1ginas 24-31, 1995. [3] W. Cede\u00f1o and V. Vemuri. Multi-niche crowding in genetic algorithms and its application to the assembly of dna restriction-fragments. Evolutionary Computation, 2(4):321-345, 1995. [4] S.W. Mahfoud. Crowding and preselection revised. Parallel Problem Solving from Nature 2, p\u00e1ginas 27-36, 1992. operators._selection # ?_selection THERE ARE TWO TYPES OF SELECTION. THE ONE THAT SELECTS FUTURE PARENTS AND SELECTS THEM PARENTS TO CROSS THEM Matching techniques: Parents can be selected in a way that maintains the diversity of the population 1) Prohibition of crossing based on ancestry. An individual cannot mate with himself, nor with his parents, nor with his children, nor with his siblings. 2) Prohibition of incest. Two parents intersect if their Hamming distance is above a certain threshold 3) Varied pairing. One individual crosses paths with another who is quite different. Hamming distance THE ONE THAT SELECTS A NEW GENERATION 1) Random Selection (RS) 2) Tournament Selection (TS): choose the best individual fitness among N randomly selected individuals (N = 2, 3,...) The selection by tournament, constitutes a very extended selection procedure of parents and in which The idea is to randomly pick a number of individuals from the population, size of the tournament, (with or without replacement), select the best individual from this group, and repeat the process until the number of individuals selected matches the size of the population. Usually the tournament size is 2, and in this case a probabilistic version has been used in which it is allowed the selection of individuals without necessarily being the best. 3) Linear Rank Selection (LRS): the population is ordered according to its fitness and a selection probability is associated with each individual that depends on their order 4) Selection by Roulette (Roulette Selection, RS): assigns a selection probability proportional to the fitness value of the individual Baker (1987) introduces a method called universal stochastic sampling, which uses a single turn of the roulette being the circular sectors proportional to the objective function. The individuals are selected from markers, equally spaced and with a random start. (genetic algorithms.pdf) 5) Elitist: In the elitist selection model, the best individual in the population is forced to at time t, be selected as the parent. Parameters ---------- chromosomes : List of chromosomes of the population size : Number of individuals to select from the population. This parameter is not considered with method = 'elitist'. N : Number of Genes to print (if trace is True) trace : Should be the chromosomes and the selection printed on the screen method: The method used for selection: ['random', 'tournament', 'linear', 'roulette', 'elitist'] Returns ------- fitness : The fitness of each chromosome (individual) psel : Probabilities of selecction of each chromosome. pesl(x) = f(x) / sum(f(y)), for each x in y selecction : List of selected chromosomes Notes ----- The aim of this function is to evaluate the fitness of each population (by the chromosome structure) and to asign a probability to select for a new population (next generation). Examples -------- >>> A_ = [] >>> A_.append(chromosome(genes = '01010001010110100100', nwt = 10, nko = 10, fitness = 2.3454)) >>> A_.append(chromosome(genes = '01011011110110100100', nwt = 10, nko = 10, fitness = 1.4401)) >>> A_.append(chromosome(genes = '01010001010100000100', nwt = 10, nko = 10, fitness = 0.9254)) >>> A_.append(chromosome(genes = '01110101010110100100', nwt = 10, nko = 10, fitness = 7.1104)) >>> A_.append(chromosome(genes = '01010101110111100100', nwt = 10, nko = 10, fitness = 2.1494)) >>> A_.append(chromosome(genes = '01010001110000100100', nwt = 10, nko = 10, fitness = 1.9954)) >>> A_.append(chromosome(genes = '00000000010110100100', nwt = 10, nko = 10, fitness = 1.7323)) >>> A_.append(chromosome(genes = '01010000111110100111', nwt = 10, nko = 10, fitness = 1.5002)) >>> A_.append(chromosome(genes = '01110011010110100111', nwt = 10, nko = 10, fitness = 2.4119)) >>> A_.append(chromosome(genes = '01010011011110101100', nwt = 10, nko = 10, fitness = 2.1414)) >>> selection, fit, ps, sel_mean, sel_maximun = _selection(A_, size = 4, N = 8, trace = True, method = 'roulette') |---------------------------------------------------------------------------------------------| |-------------- fenotypes ---------------||--- genotypes ---||--- fitness ---||- Probability -| 01010001...01000101 || 01101001...10100100 4 4 2.3454 0.09912204 01011011...01101111 || 01101001...10100100 7 4 1.4401 0.07244166 01010001...01000101 || 01000001...00000100 4 2 0.9254 0.05727278 01110101...11010101 || 01101001...10100100 6 4 7.1104 0.23955286 01010101...01010111 || 01111001...11100100 6 5 2.1494 0.09334567 01010001...01000111 || 00001001...00100100 5 2 1.9954 0.08880708 00000000...00000001 || 01101001...10100100 1 4 1.7323 0.08105318 01010000...01000011 || 11101001...10100111 4 7 1.5002 0.07421289 01110011...11001101 || 01101001...10100111 6 6 2.4119 0.10108189 01010011...01001101 || 11101011...10101100 5 6 2.1414 0.09310990 |---------------------------------------------------------------------------------------------| |-------------- fenotypes ---------------||--- genotypes ---||--- fitness ---||- Probability -| 01110101...11010101 || 01101001...10100100 6 4 7.1104 0.23955286 01010001...01000101 || 01101001...10100100 4 4 2.3454 0.09912204 01010001...01000111 || 00001001...00100100 5 2 1.9954 0.08880708 01010011...01001101 || 11101011...10101100 5 6 2.1414 0.09310990 >>> selection, fit, ps, sel_mean, sel_maximun = _selection(A_, size = 4, N = 8, trace = True, method = 'linear') |---------------------------------------------------------------------------------------------| |-------------- fenotypes ---------------||--- genotypes ---||--- fitness ---||- Probability -| 01010001...01000101 || 01101001...10100100 4 4 2.3454 0.15555555 01011011...01101111 || 01101001...10100100 7 4 1.4401 0.02222222 01010001...01000101 || 01000001...00000100 4 2 0.9254 0.0 01110101...11010101 || 01101001...10100100 6 4 7.1104 0.2 01010101...01010111 || 01111001...11100100 6 5 2.1494 0.13333333 01010001...01000111 || 00001001...00100100 5 2 1.9954 0.08888888 00000000...00000001 || 01101001...10100100 1 4 1.7323 0.06666666 01010000...01000011 || 11101001...10100111 4 7 1.5002 0.04444444 01110011...11001101 || 01101001...10100111 6 6 2.4119 0.17777777 01010011...01001101 || 11101011...10101100 5 6 2.1414 0.11111111 |---------------------------------------------------------------------------------------------| |-------------- fenotypes ---------------||--- genotypes ---||--- fitness ---||- Probability -| 01011011...01101111 || 01101001...10100100 7 4 1.4401 0.02222222 01010000...01000011 || 11101001...10100111 4 7 1.5002 0.04444444 01110101...11010101 || 01101001...10100100 6 4 7.1104 0.2 01010001...01000101 || 01101001...10100100 4 4 2.3454 0.15555555 >>> selection, fit, ps, sel_mean, sel_maximun = _selection(A_, size = 4, N = 8, trace = True, method = 'random') |---------------------------------------------------------------------------------------------| |-------------- fenotypes ---------------||--- genotypes ---||--- fitness ---||- Probability -| 01010001...01000101 || 01101001...10100100 4 4 2.3454 0.1 01011011...01101111 || 01101001...10100100 7 4 1.4401 0.1 01010001...01000101 || 01000001...00000100 4 2 0.9254 0.1 01110101...11010101 || 01101001...10100100 6 4 7.1104 0.1 01010101...01010111 || 01111001...11100100 6 5 2.1494 0.1 01010001...01000111 || 00001001...00100100 5 2 1.9954 0.1 00000000...00000001 || 01101001...10100100 1 4 1.7323 0.1 01010000...01000011 || 11101001...10100111 4 7 1.5002 0.1 01110011...11001101 || 01101001...10100111 6 6 2.4119 0.1 01010011...01001101 || 11101011...10101100 5 6 2.1414 0.1 |---------------------------------------------------------------------------------------------| |-------------- fenotypes ---------------||--- genotypes ---||--- fitness ---||- Probability -| 01010101...01010111 || 01111001...11100100 6 5 2.1494 0.1 01010001...01000101 || 01000001...00000100 4 2 0.9254 0.1 01010011...01001101 || 11101011...10101100 5 6 2.1414 0.1 01010001...01000101 || 01101001...10100100 4 4 2.3454 0.1 >>> selection, fit, ps, sel_mean, sel_maximun = _selection(A_, size = 4, N = 8, trace = True, method = 'elitist') |---------------------------------------------------------------------------------------------| |-------------- fenotypes ---------------||--- genotypes ---||--- fitness ---||- Probability -| 01010001...01000101 || 01101001...10100100 4 4 2.3454 ---------- 01011011...01101111 || 01101001...10100100 7 4 1.4401 ---------- 01010001...01000101 || 01000001...00000100 4 2 0.9254 ---------- 01110101...11010101 || 01101001...10100100 6 4 7.1104 ---------- 01010101...01010111 || 01111001...11100100 6 5 2.1494 ---------- 01010001...01000111 || 00001001...00100100 5 2 1.9954 ---------- 00000000...00000001 || 01101001...10100100 1 4 1.7323 ---------- 01010000...01000011 || 11101001...10100111 4 7 1.5002 ---------- 01110011...11001101 || 01101001...10100111 6 6 2.4119 ---------- 01010011...01001101 || 11101011...10101100 5 6 2.1414 ---------- |---------------------------------------------------------------------------------------------| |-------------- fenotypes ---------------||--- genotypes ---||--- fitness ---||- Probability -| 01010101...01010111 || 01111001...11100100 6 5 2.1494 ---------- 01010001...01000101 || 01101001...10100100 4 4 2.3454 ---------- 01110011...11001101 || 01101001...10100111 6 6 2.4119 ---------- 01110101...11010101 || 01101001...10100100 6 4 7.1104 ---------- >>> selection, fit, ps, sel_mean, sel_maximun = _selection(A_, size = 4, N = 8, trace = True, method = 'tournament') |---------------------------------------------------------------------------------------------| |-------------- fenotypes ---------------||--- genotypes ---||--- fitness ---||- Probability -| 01010001...01000101 || 01101001...10100100 4 4 2.3454 ---------- 01011011...01101111 || 01101001...10100100 7 4 1.4401 ---------- 01010001...01000101 || 01000001...00000100 4 2 0.9254 ---------- 01110101...11010101 || 01101001...10100100 6 4 7.1104 ---------- 01010101...01010111 || 01111001...11100100 6 5 2.1494 ---------- 01010001...01000111 || 00001001...00100100 5 2 1.9954 ---------- 00000000...00000001 || 01101001...10100100 1 4 1.7323 ---------- 01010000...01000011 || 11101001...10100111 4 7 1.5002 ---------- 01110011...11001101 || 01101001...10100111 6 6 2.4119 ---------- 01010011...01001101 || 11101011...10101100 5 6 2.1414 ---------- |---------------------------------------------------------------------------------------------| |-------------- fenotypes ---------------||--- genotypes ---||--- fitness ---||- Probability -| 00000000...00000001 || 01101001...10100100 1 4 1.7323 ---------- 01010000...01000011 || 11101001...10100111 4 7 1.5002 ---------- 01110011...11001101 || 01101001...10100111 6 6 2.4119 ---------- 01010101...01010111 || 01111001...11100100 6 5 2.1494 ---------- 01110101...11010101 || 01101001...10100100 6 4 7.1104 ----------","title":"Operators"},{"location":"package/package/operators.html#operators","text":"Import the pygenmet package from ..tools.tools import chromosome import pandas as pd import numpy as np","title":"Operators"},{"location":"package/package/operators.html#crossover","text":"In Genetic Algorithms the crossover (also called recombination) is a genetic operator used to combine the genetic information of two parents to generate new offspring.","title":"Crossover"},{"location":"package/package/operators.html#operators_crossover","text":"The docstring associated to the _crossover function is the following. ?_crossover Parameters ---------- chromosome_a: Chromosome chromosome_b: Chromosome k: k-point. If k = 1 the method will be single-point crossover, If k = 2 the method will be two-point crossover. If k = N (with N the length of chromosome) the method will be the uniform crossover. Its value is 1 by default. Returns ------- Two new chromosomes Notes ----- [1] References ---------- [1] https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm) Examples -------- >>> A = _get_father(nwt = dwt.shape[0], nko = dko.shape[0], dwt = dwt, dko = dko, geneSet = '01', get_fitness = _get_fitness, obj = np.array(FC.loc[:, murine_models_in[4]])) >>> B = _get_father(nwt = dwt.shape[0], nko = dko.shape[0], dwt = dwt, dko = dko, geneSet = '01', get_fitness = _get_fitness, obj = np.array(FC.loc[:, murine_models_in[4]])) >>> A.print() 011000111111010 ... 001000010001110 || 001010011000110 ... 011001001111111 43 336 0.03363686825576087 >>> B.print() 100101111101111 ... 010001000100101 || 010101001001010 ... 111010000101010 42 345 0.1410663212679354 >>> A1, B1 = _crossover(A, B, get_fitness = _get_fitness, nwt = dwt.shape[0], nko = dko.shape[0], dwt = dwt, dko = dko, obj = np.array(FC.loc[:, murine_models_in[4]]), k = 1) >>> A1.print() 011000111111010 ... 001000010001110 || 001010011000110 ... 111010000101010 43 327 0.007288743389698732 >>> B1.print() 100101111101111 ... 010001000100101 || 010101001001010 ... 011001001111111 42 354 0.15370276754212897 >>> A1, B1 = _crossover(A, B, get_fitness = _get_fitness, nwt = dwt.shape[0], nko = dko.shape[0], dwt = dwt, dko = dko, obj = np.array(FC.loc[:, murine_models_in[4]]), k = 772) >>> A1.print() 110000111101111 ... 000000010001111 || 011111001001110 ... 011000001111111 43 355 0.017131591198246282 >>> B1.print() 001101111111010 ... 011001000100100 || 000000011000010 ... 111011000101010 42 326 0.13633106854522628","title":"operators._crossover"},{"location":"package/package/operators.html#operators_arithmetic_crossover","text":"?_arithmetic_crossover Notes ----- For this specific genotype (GeneSet = '01') the arithmetic crossover techniques are available. These techniques are: [1] AND [2] OR [3] XOR Arithmetic crossover - some arithmetic operation is performed to make a new offspring [1] References ---------- [1] https://www.obitko.com/tutorials/genetic-algorithms/crossover-mutation.php ```{table} Truth table for AND, OR and XOR logical operators. :align: center :width: 80% :name: truth_table | A | B | AND | OR | XOR | |:-:|:-:|:-:|:-:|:-:| | 0 | 0 | 0 | 0 | 0 | | 0 | 1 | 0 | 1 | 1 | | 1 | 0 | 0 | 1 | 1 | | 1 | 1 | 1 | 1 | 0 | ## Mutation See {ref}`theory:mutation` for the theory and definitions. ### operators.\\_mutation ```python ?_mutation Parameters ---------- father : Genes of the father geneSet : Set of genes availables. Usually '0' and '1' get_fitness : Function to improve nwt : Number of No NAFLD Samples nko : Number of NAFLD Samples dwt : Data of No NAFLD Samples dko : Data of NAFLD Samples obj : The fold-changes of murine model to adjust type : Type of mutation process, 'bsm' by default. Five types are allowed. bf : bitflip bsm : bitstringmutation sw : swap in : inversion sc : scramble p : Parameter to modify the posibility of change in a genes Returns ------- A new mutated chromosome by the type of mutation process Notes ----- The flipbit (fb) mutation is an aggressive mutation because change all genes. If in a specific gen the allelo value is '0' this process will change it to '1'. fb: '0101010101' -> '1010101010' The bitstringmutation (bsm) mutation process will change a gen with a probability 'p'. If p = None then p = 1/len(genes) [1]. bsm: '0101010101' -> '0101110101' References ---------- [1] https://en.wikipedia.org/wiki/Mutation_(genetic_algorithm) [2] https://www.tutorialspoint.com/genetic_algorithms/genetic_algorithms_mutation.htm Examples --------","title":"operators._arithmetic_crossover"},{"location":"package/package/operators.html#selection","text":"","title":"Selection"},{"location":"package/package/operators.html#operators_replacement","text":"?_replacement Parameters ---------- type : Type of replacement rws : Replace Worst Strategy rts : Restricted Tournament Selection wams : Worst Among Most Similar Replacement Notes ----- The _replacement function is ised to change the old generation population with the new generation. Four process have been evaluated [1]: 1) Replace Worst Strategy (RW). The worst element of the population is replaced if the child improves it. It offers high selective pressure, even when its parents are chosen randomly. 2) Restricted Tournament Selection (RTS) [2]. 3) Replace the Worst Among Most Similar Replacement (WAMS) [3]. the worst chromosome of the set of the N (N = 3,...) parents most similar to the offspring. 4) Deterministic Crowding Algorithm (Deterministic Crowding, DC) [4]. To facilitate the comparison we will use in our experiments. A variant of the DC in which a single descendant will be generated for each cross, which will replace the most similar parent if it improves it. References ---------- [1] https://sci2s.ugr.es/keel/pdf/keel/congreso/4-diversidadfinal2_daniel_molina.pdf [2] G. Harik. Finding multimodal solutions using restricted tournament selection. Proc. 6th Int. Conf. Genetic Algorithms, p\u00e1ginas 24-31, 1995. [3] W. Cede\u00f1o and V. Vemuri. Multi-niche crowding in genetic algorithms and its application to the assembly of dna restriction-fragments. Evolutionary Computation, 2(4):321-345, 1995. [4] S.W. Mahfoud. Crowding and preselection revised. Parallel Problem Solving from Nature 2, p\u00e1ginas 27-36, 1992.","title":"operators._replacement"},{"location":"package/package/operators.html#operators_selection","text":"?_selection THERE ARE TWO TYPES OF SELECTION. THE ONE THAT SELECTS FUTURE PARENTS AND SELECTS THEM PARENTS TO CROSS THEM Matching techniques: Parents can be selected in a way that maintains the diversity of the population 1) Prohibition of crossing based on ancestry. An individual cannot mate with himself, nor with his parents, nor with his children, nor with his siblings. 2) Prohibition of incest. Two parents intersect if their Hamming distance is above a certain threshold 3) Varied pairing. One individual crosses paths with another who is quite different. Hamming distance THE ONE THAT SELECTS A NEW GENERATION 1) Random Selection (RS) 2) Tournament Selection (TS): choose the best individual fitness among N randomly selected individuals (N = 2, 3,...) The selection by tournament, constitutes a very extended selection procedure of parents and in which The idea is to randomly pick a number of individuals from the population, size of the tournament, (with or without replacement), select the best individual from this group, and repeat the process until the number of individuals selected matches the size of the population. Usually the tournament size is 2, and in this case a probabilistic version has been used in which it is allowed the selection of individuals without necessarily being the best. 3) Linear Rank Selection (LRS): the population is ordered according to its fitness and a selection probability is associated with each individual that depends on their order 4) Selection by Roulette (Roulette Selection, RS): assigns a selection probability proportional to the fitness value of the individual Baker (1987) introduces a method called universal stochastic sampling, which uses a single turn of the roulette being the circular sectors proportional to the objective function. The individuals are selected from markers, equally spaced and with a random start. (genetic algorithms.pdf) 5) Elitist: In the elitist selection model, the best individual in the population is forced to at time t, be selected as the parent. Parameters ---------- chromosomes : List of chromosomes of the population size : Number of individuals to select from the population. This parameter is not considered with method = 'elitist'. N : Number of Genes to print (if trace is True) trace : Should be the chromosomes and the selection printed on the screen method: The method used for selection: ['random', 'tournament', 'linear', 'roulette', 'elitist'] Returns ------- fitness : The fitness of each chromosome (individual) psel : Probabilities of selecction of each chromosome. pesl(x) = f(x) / sum(f(y)), for each x in y selecction : List of selected chromosomes Notes ----- The aim of this function is to evaluate the fitness of each population (by the chromosome structure) and to asign a probability to select for a new population (next generation). Examples -------- >>> A_ = [] >>> A_.append(chromosome(genes = '01010001010110100100', nwt = 10, nko = 10, fitness = 2.3454)) >>> A_.append(chromosome(genes = '01011011110110100100', nwt = 10, nko = 10, fitness = 1.4401)) >>> A_.append(chromosome(genes = '01010001010100000100', nwt = 10, nko = 10, fitness = 0.9254)) >>> A_.append(chromosome(genes = '01110101010110100100', nwt = 10, nko = 10, fitness = 7.1104)) >>> A_.append(chromosome(genes = '01010101110111100100', nwt = 10, nko = 10, fitness = 2.1494)) >>> A_.append(chromosome(genes = '01010001110000100100', nwt = 10, nko = 10, fitness = 1.9954)) >>> A_.append(chromosome(genes = '00000000010110100100', nwt = 10, nko = 10, fitness = 1.7323)) >>> A_.append(chromosome(genes = '01010000111110100111', nwt = 10, nko = 10, fitness = 1.5002)) >>> A_.append(chromosome(genes = '01110011010110100111', nwt = 10, nko = 10, fitness = 2.4119)) >>> A_.append(chromosome(genes = '01010011011110101100', nwt = 10, nko = 10, fitness = 2.1414)) >>> selection, fit, ps, sel_mean, sel_maximun = _selection(A_, size = 4, N = 8, trace = True, method = 'roulette') |---------------------------------------------------------------------------------------------| |-------------- fenotypes ---------------||--- genotypes ---||--- fitness ---||- Probability -| 01010001...01000101 || 01101001...10100100 4 4 2.3454 0.09912204 01011011...01101111 || 01101001...10100100 7 4 1.4401 0.07244166 01010001...01000101 || 01000001...00000100 4 2 0.9254 0.05727278 01110101...11010101 || 01101001...10100100 6 4 7.1104 0.23955286 01010101...01010111 || 01111001...11100100 6 5 2.1494 0.09334567 01010001...01000111 || 00001001...00100100 5 2 1.9954 0.08880708 00000000...00000001 || 01101001...10100100 1 4 1.7323 0.08105318 01010000...01000011 || 11101001...10100111 4 7 1.5002 0.07421289 01110011...11001101 || 01101001...10100111 6 6 2.4119 0.10108189 01010011...01001101 || 11101011...10101100 5 6 2.1414 0.09310990 |---------------------------------------------------------------------------------------------| |-------------- fenotypes ---------------||--- genotypes ---||--- fitness ---||- Probability -| 01110101...11010101 || 01101001...10100100 6 4 7.1104 0.23955286 01010001...01000101 || 01101001...10100100 4 4 2.3454 0.09912204 01010001...01000111 || 00001001...00100100 5 2 1.9954 0.08880708 01010011...01001101 || 11101011...10101100 5 6 2.1414 0.09310990 >>> selection, fit, ps, sel_mean, sel_maximun = _selection(A_, size = 4, N = 8, trace = True, method = 'linear') |---------------------------------------------------------------------------------------------| |-------------- fenotypes ---------------||--- genotypes ---||--- fitness ---||- Probability -| 01010001...01000101 || 01101001...10100100 4 4 2.3454 0.15555555 01011011...01101111 || 01101001...10100100 7 4 1.4401 0.02222222 01010001...01000101 || 01000001...00000100 4 2 0.9254 0.0 01110101...11010101 || 01101001...10100100 6 4 7.1104 0.2 01010101...01010111 || 01111001...11100100 6 5 2.1494 0.13333333 01010001...01000111 || 00001001...00100100 5 2 1.9954 0.08888888 00000000...00000001 || 01101001...10100100 1 4 1.7323 0.06666666 01010000...01000011 || 11101001...10100111 4 7 1.5002 0.04444444 01110011...11001101 || 01101001...10100111 6 6 2.4119 0.17777777 01010011...01001101 || 11101011...10101100 5 6 2.1414 0.11111111 |---------------------------------------------------------------------------------------------| |-------------- fenotypes ---------------||--- genotypes ---||--- fitness ---||- Probability -| 01011011...01101111 || 01101001...10100100 7 4 1.4401 0.02222222 01010000...01000011 || 11101001...10100111 4 7 1.5002 0.04444444 01110101...11010101 || 01101001...10100100 6 4 7.1104 0.2 01010001...01000101 || 01101001...10100100 4 4 2.3454 0.15555555 >>> selection, fit, ps, sel_mean, sel_maximun = _selection(A_, size = 4, N = 8, trace = True, method = 'random') |---------------------------------------------------------------------------------------------| |-------------- fenotypes ---------------||--- genotypes ---||--- fitness ---||- Probability -| 01010001...01000101 || 01101001...10100100 4 4 2.3454 0.1 01011011...01101111 || 01101001...10100100 7 4 1.4401 0.1 01010001...01000101 || 01000001...00000100 4 2 0.9254 0.1 01110101...11010101 || 01101001...10100100 6 4 7.1104 0.1 01010101...01010111 || 01111001...11100100 6 5 2.1494 0.1 01010001...01000111 || 00001001...00100100 5 2 1.9954 0.1 00000000...00000001 || 01101001...10100100 1 4 1.7323 0.1 01010000...01000011 || 11101001...10100111 4 7 1.5002 0.1 01110011...11001101 || 01101001...10100111 6 6 2.4119 0.1 01010011...01001101 || 11101011...10101100 5 6 2.1414 0.1 |---------------------------------------------------------------------------------------------| |-------------- fenotypes ---------------||--- genotypes ---||--- fitness ---||- Probability -| 01010101...01010111 || 01111001...11100100 6 5 2.1494 0.1 01010001...01000101 || 01000001...00000100 4 2 0.9254 0.1 01010011...01001101 || 11101011...10101100 5 6 2.1414 0.1 01010001...01000101 || 01101001...10100100 4 4 2.3454 0.1 >>> selection, fit, ps, sel_mean, sel_maximun = _selection(A_, size = 4, N = 8, trace = True, method = 'elitist') |---------------------------------------------------------------------------------------------| |-------------- fenotypes ---------------||--- genotypes ---||--- fitness ---||- Probability -| 01010001...01000101 || 01101001...10100100 4 4 2.3454 ---------- 01011011...01101111 || 01101001...10100100 7 4 1.4401 ---------- 01010001...01000101 || 01000001...00000100 4 2 0.9254 ---------- 01110101...11010101 || 01101001...10100100 6 4 7.1104 ---------- 01010101...01010111 || 01111001...11100100 6 5 2.1494 ---------- 01010001...01000111 || 00001001...00100100 5 2 1.9954 ---------- 00000000...00000001 || 01101001...10100100 1 4 1.7323 ---------- 01010000...01000011 || 11101001...10100111 4 7 1.5002 ---------- 01110011...11001101 || 01101001...10100111 6 6 2.4119 ---------- 01010011...01001101 || 11101011...10101100 5 6 2.1414 ---------- |---------------------------------------------------------------------------------------------| |-------------- fenotypes ---------------||--- genotypes ---||--- fitness ---||- Probability -| 01010101...01010111 || 01111001...11100100 6 5 2.1494 ---------- 01010001...01000101 || 01101001...10100100 4 4 2.3454 ---------- 01110011...11001101 || 01101001...10100111 6 6 2.4119 ---------- 01110101...11010101 || 01101001...10100100 6 4 7.1104 ---------- >>> selection, fit, ps, sel_mean, sel_maximun = _selection(A_, size = 4, N = 8, trace = True, method = 'tournament') |---------------------------------------------------------------------------------------------| |-------------- fenotypes ---------------||--- genotypes ---||--- fitness ---||- Probability -| 01010001...01000101 || 01101001...10100100 4 4 2.3454 ---------- 01011011...01101111 || 01101001...10100100 7 4 1.4401 ---------- 01010001...01000101 || 01000001...00000100 4 2 0.9254 ---------- 01110101...11010101 || 01101001...10100100 6 4 7.1104 ---------- 01010101...01010111 || 01111001...11100100 6 5 2.1494 ---------- 01010001...01000111 || 00001001...00100100 5 2 1.9954 ---------- 00000000...00000001 || 01101001...10100100 1 4 1.7323 ---------- 01010000...01000011 || 11101001...10100111 4 7 1.5002 ---------- 01110011...11001101 || 01101001...10100111 6 6 2.4119 ---------- 01010011...01001101 || 11101011...10101100 5 6 2.1414 ---------- |---------------------------------------------------------------------------------------------| |-------------- fenotypes ---------------||--- genotypes ---||--- fitness ---||- Probability -| 00000000...00000001 || 01101001...10100100 1 4 1.7323 ---------- 01010000...01000011 || 11101001...10100111 4 7 1.5002 ---------- 01110011...11001101 || 01101001...10100111 6 6 2.4119 ---------- 01010101...01010111 || 01111001...11100100 6 5 2.1494 ---------- 01110101...11010101 || 01101001...10100100 6 4 7.1104 ----------","title":"operators._selection"},{"location":"package/package/tools.html","text":"Tools # Import the pygenmet package from pygenmet import * import pandas as pd import numpy as np tools._get_father # With the function \\_get\\_father() we can to generate an initial solution. We can to initializate nwt , dwt , nko and dko . For replicate purpose, this function has the random_state argument. The docstring associated to the _get_father function is the following. ?_get_father Parameters ---------- nwt : Number of observations of Wild Type nko : Number of observations of Knock-out dwt : Data of observations of Wild Type dko : Data of observations of Knock-out geneSet: Usually a list as '01' get_fitness: The fitness function to use obj : Array of fold-changes of metabolites in murine model random_state: If you don't mention the random_state in the code, then whenever you execute your code a new random value Returns ------- This function returns a chromosome Examples -------- >>> _get_father(nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = _get_fitness, obj = FC.FC).print() 011101101010000 ... 000000001000001 || 101110011001010 ... 011110110000011 37 261 -0.04568152517704738 >>> _get_father(nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = _get_fitness, obj = FC.FC).print() 000101011001011 ... 101100010101101 || 010000101000100 ... 110111010001010 46 252 -0.07192848665245967 >>> _get_father(nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = _get_fitness, obj = FC.FC).print() 110101100111011 ... 000110110110111 || 110010000110100 ... 110010011101011 49 267 -0.11718322152992591 nwt = 15 nko = 25 dwt = pd.DataFrame(np.random.rand(nwt,10)) dko = pd.DataFrame(np.random.rand(nko,10)) for i in np.arange(10): A = _get_father(nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = _get_fitness, obj = [1,0,1,-1,1,0,0,1,0.5, 0.5]) A.print() 000100010101011 ... 000100010101011 || 010011110000011 ... 000110111000101 6 12 -0.01750455939922404 010100000111001 ... 010100000111001 || 000111111010001 ... 100010010110110 6 13 0.01583165234542458 001010100111101 ... 001010100111101 || 101110011011111 ... 111110100001101 8 15 0.1337101625593648 011011101001110 ... 011011101001110 || 011111111111101 ... 111010000110111 9 18 0.3326538149497444 101100111001001 ... 101100111001001 || 010100110110000 ... 100001010110001 8 11 0.09708129202192302 010001010010001 ... 010001010010001 || 100111000100111 ... 001110100100100 5 11 0.1442876222067664 000000000011101 ... 000000000011101 || 100100011111100 ... 111000011110101 4 14 0.28826914052937097 110100111110100 ... 110100111110100 || 111011001010111 ... 101111010101001 9 15 -0.377007167796123 100111000110010 ... 100111000110010 || 111001110110000 ... 100001101111100 7 15 0.3216335311818925 000111101101000 ... 000111101101000 || 100010011101100 ... 011001100001110 7 12 -0.09813075927314555 for i in np.arange(10): A = _get_father(nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = _get_fitness, obj = [1,0,1,-1,1,0,0,1,0.5, 0.5], random_state = 42) A.print() 100011100001001 ... 100011100001001 || 101101100100011 ... 000111111011111 6 17 0.04061614908467767 100011100001001 ... 100011100001001 || 101101100100011 ... 000111111011111 6 17 0.04061614908467767 100011100001001 ... 100011100001001 || 101101100100011 ... 000111111011111 6 17 0.04061614908467767 100011100001001 ... 100011100001001 || 101101100100011 ... 000111111011111 6 17 0.04061614908467767 100011100001001 ... 100011100001001 || 101101100100011 ... 000111111011111 6 17 0.04061614908467767 100011100001001 ... 100011100001001 || 101101100100011 ... 000111111011111 6 17 0.04061614908467767 100011100001001 ... 100011100001001 || 101101100100011 ... 000111111011111 6 17 0.04061614908467767 100011100001001 ... 100011100001001 || 101101100100011 ... 000111111011111 6 17 0.04061614908467767 100011100001001 ... 100011100001001 || 101101100100011 ... 000111111011111 6 17 0.04061614908467767 100011100001001 ... 100011100001001 || 101101100100011 ... 000111111011111 6 17 0.04061614908467767 tools._get_population # The docstring associated to the _get_population function is the following. ?_get_population Parameters ---------- individuals : Number of individual of first generation or initial population nwt : Number of observations of Wild Type nko : Number of observations of Knock-out dwt : Data of observations of Wild Type dko : Data of observations of Knock-out geneSet : Usually a list as '01' get_fitness : The fitness function to use obj : Array of fold-changes of metabolites in murine model random_state : If you don't mention the random_state in the code, then whenever you execute your code a new random value Returns ------- population_ : A list of the initial population (chromosomes) to initialize the algorithm Notes ----- Examples -------- >>> nwt = 15 >>> nko = 25 >>> dwt = pd.DataFrame(np.random.rand(nwt,10)) >>> dko = pd.DataFrame(np.random.rand(nko,10)) >>> A = _get_population(individuals = 10, nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = _get_fitness, obj = [1,0,1,-1,1,0,0,1,0.5, 0.5]) >>> [A_.print() for A_ in A]; 110101101011111 ... 110101101011111 || 101110000011110 ... 111101111110101 11 16 0.27010320047631353 110001101000111 ... 110001101000111 || 111011001000100 ... 001001100010011 8 12 0.4153593539526977 110110110000111 ... 110110110000111 || 111001000001001 ... 010011110110101 9 13 0.24120026823063395 001001101100010 ... 001001101100010 || 101000001100111 ... 001110111010010 6 12 0.5976992970173265 110110101000111 ... 110110101000111 || 100011000000110 ... 001100011111011 9 12 0.4327563879291974 010110111011011 ... 010110111011011 || 101101110101111 ... 011110010010000 10 13 0.19109063637942147 011011111001110 ... 011011111001110 || 000001110011000 ... 110001111010111 10 13 0.19291545113399683 100010011100001 ... 100010011100001 || 011101010010100 ... 101001111100011 6 14 0.3838922708272582 110001111111010 ... 110001111111010 || 110111010001010 ... 010100000000100 10 9 0.04833875255418793 001111011101100 ... 001111011101100 || 100011000100101 ... 001010101000110 9 10 0.6180057110908423 nwt = 15 nko = 25 dwt = pd.DataFrame(np.random.rand(nwt,10)) dko = pd.DataFrame(np.random.rand(nko,10)) A = _get_population(individuals = 10, nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = _get_fitness, obj = [1,0,1,-1,1,0,0,1,0.5, 0.5]) [A_.print() for A_ in A]; 001100101100011 ... 001100101100011 || 010111011100111 ... 001111010101001 7 15 0.22717953288324988 011111001110011 ... 011111001110011 || 110011011010001 ... 100011100110100 10 13 -0.14158703160537597 000111000110010 ... 000111000110010 || 000111011011101 ... 111010101101111 6 16 -0.14752436179984593 111110011001001 ... 111110011001001 || 111101011001011 ... 010111111010101 9 17 0.37230832910925965 111100011100110 ... 111100011100110 || 001000100111010 ... 110100000100011 9 9 0.09942842284405343 011100001011101 ... 011100001011101 || 001010010010100 ... 101000010010000 8 7 -0.29440398210415947 111011011011101 ... 111011011011101 || 000101001001101 ... 011011010111110 11 13 0.262667504755609 000000010010100 ... 000000010010100 || 111110001111110 ... 111101010010111 3 17 -0.3603100204852186 111110110010001 ... 111110110010001 || 100101000011100 ... 111000110100010 9 10 -0.254079327688995 001010010000000 ... 001010010000000 || 100111101001111 ... 011111000011110 3 15 0.3651577081778396 tools._read_chromosome # This function read the chromosome information from a file and it is loaded in memory. The file can be generated by to_json() method. The docstring associated to the _read_chromosome function is the following. ?_read_chromosome Parameters ---------- path_or_buf : string or file handle. File path or object. Returns ------- This function returns a chromosome Examples -------- >>> A = chromosome(genes = '00100101001001011000111010110010', nko=16, nwt=16, fitness=0.98) >>> A.print(5) 00100 ... 00101 || 10001 ... 10010 6 8 0.98 >>> A.to_json('prueba.json') >>> B = _read_chromosome('prueba.json') >>> B.print(10) 0010010100 ... 0100100101 || 1000111010 ... 1010110010 6 8 0.98 new_CH = _read_chromosome(path_or_buf = 'out.json') new_CH.print() 0110101101 ... 0110101101 || 011000111101101 ... 011010110001111 6 18 0.4125","title":"Tools"},{"location":"package/package/tools.html#tools","text":"Import the pygenmet package from pygenmet import * import pandas as pd import numpy as np","title":"Tools"},{"location":"package/package/tools.html#tools_get_father","text":"With the function \\_get\\_father() we can to generate an initial solution. We can to initializate nwt , dwt , nko and dko . For replicate purpose, this function has the random_state argument. The docstring associated to the _get_father function is the following. ?_get_father Parameters ---------- nwt : Number of observations of Wild Type nko : Number of observations of Knock-out dwt : Data of observations of Wild Type dko : Data of observations of Knock-out geneSet: Usually a list as '01' get_fitness: The fitness function to use obj : Array of fold-changes of metabolites in murine model random_state: If you don't mention the random_state in the code, then whenever you execute your code a new random value Returns ------- This function returns a chromosome Examples -------- >>> _get_father(nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = _get_fitness, obj = FC.FC).print() 011101101010000 ... 000000001000001 || 101110011001010 ... 011110110000011 37 261 -0.04568152517704738 >>> _get_father(nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = _get_fitness, obj = FC.FC).print() 000101011001011 ... 101100010101101 || 010000101000100 ... 110111010001010 46 252 -0.07192848665245967 >>> _get_father(nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = _get_fitness, obj = FC.FC).print() 110101100111011 ... 000110110110111 || 110010000110100 ... 110010011101011 49 267 -0.11718322152992591 nwt = 15 nko = 25 dwt = pd.DataFrame(np.random.rand(nwt,10)) dko = pd.DataFrame(np.random.rand(nko,10)) for i in np.arange(10): A = _get_father(nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = _get_fitness, obj = [1,0,1,-1,1,0,0,1,0.5, 0.5]) A.print() 000100010101011 ... 000100010101011 || 010011110000011 ... 000110111000101 6 12 -0.01750455939922404 010100000111001 ... 010100000111001 || 000111111010001 ... 100010010110110 6 13 0.01583165234542458 001010100111101 ... 001010100111101 || 101110011011111 ... 111110100001101 8 15 0.1337101625593648 011011101001110 ... 011011101001110 || 011111111111101 ... 111010000110111 9 18 0.3326538149497444 101100111001001 ... 101100111001001 || 010100110110000 ... 100001010110001 8 11 0.09708129202192302 010001010010001 ... 010001010010001 || 100111000100111 ... 001110100100100 5 11 0.1442876222067664 000000000011101 ... 000000000011101 || 100100011111100 ... 111000011110101 4 14 0.28826914052937097 110100111110100 ... 110100111110100 || 111011001010111 ... 101111010101001 9 15 -0.377007167796123 100111000110010 ... 100111000110010 || 111001110110000 ... 100001101111100 7 15 0.3216335311818925 000111101101000 ... 000111101101000 || 100010011101100 ... 011001100001110 7 12 -0.09813075927314555 for i in np.arange(10): A = _get_father(nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = _get_fitness, obj = [1,0,1,-1,1,0,0,1,0.5, 0.5], random_state = 42) A.print() 100011100001001 ... 100011100001001 || 101101100100011 ... 000111111011111 6 17 0.04061614908467767 100011100001001 ... 100011100001001 || 101101100100011 ... 000111111011111 6 17 0.04061614908467767 100011100001001 ... 100011100001001 || 101101100100011 ... 000111111011111 6 17 0.04061614908467767 100011100001001 ... 100011100001001 || 101101100100011 ... 000111111011111 6 17 0.04061614908467767 100011100001001 ... 100011100001001 || 101101100100011 ... 000111111011111 6 17 0.04061614908467767 100011100001001 ... 100011100001001 || 101101100100011 ... 000111111011111 6 17 0.04061614908467767 100011100001001 ... 100011100001001 || 101101100100011 ... 000111111011111 6 17 0.04061614908467767 100011100001001 ... 100011100001001 || 101101100100011 ... 000111111011111 6 17 0.04061614908467767 100011100001001 ... 100011100001001 || 101101100100011 ... 000111111011111 6 17 0.04061614908467767 100011100001001 ... 100011100001001 || 101101100100011 ... 000111111011111 6 17 0.04061614908467767","title":"tools._get_father"},{"location":"package/package/tools.html#tools_get_population","text":"The docstring associated to the _get_population function is the following. ?_get_population Parameters ---------- individuals : Number of individual of first generation or initial population nwt : Number of observations of Wild Type nko : Number of observations of Knock-out dwt : Data of observations of Wild Type dko : Data of observations of Knock-out geneSet : Usually a list as '01' get_fitness : The fitness function to use obj : Array of fold-changes of metabolites in murine model random_state : If you don't mention the random_state in the code, then whenever you execute your code a new random value Returns ------- population_ : A list of the initial population (chromosomes) to initialize the algorithm Notes ----- Examples -------- >>> nwt = 15 >>> nko = 25 >>> dwt = pd.DataFrame(np.random.rand(nwt,10)) >>> dko = pd.DataFrame(np.random.rand(nko,10)) >>> A = _get_population(individuals = 10, nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = _get_fitness, obj = [1,0,1,-1,1,0,0,1,0.5, 0.5]) >>> [A_.print() for A_ in A]; 110101101011111 ... 110101101011111 || 101110000011110 ... 111101111110101 11 16 0.27010320047631353 110001101000111 ... 110001101000111 || 111011001000100 ... 001001100010011 8 12 0.4153593539526977 110110110000111 ... 110110110000111 || 111001000001001 ... 010011110110101 9 13 0.24120026823063395 001001101100010 ... 001001101100010 || 101000001100111 ... 001110111010010 6 12 0.5976992970173265 110110101000111 ... 110110101000111 || 100011000000110 ... 001100011111011 9 12 0.4327563879291974 010110111011011 ... 010110111011011 || 101101110101111 ... 011110010010000 10 13 0.19109063637942147 011011111001110 ... 011011111001110 || 000001110011000 ... 110001111010111 10 13 0.19291545113399683 100010011100001 ... 100010011100001 || 011101010010100 ... 101001111100011 6 14 0.3838922708272582 110001111111010 ... 110001111111010 || 110111010001010 ... 010100000000100 10 9 0.04833875255418793 001111011101100 ... 001111011101100 || 100011000100101 ... 001010101000110 9 10 0.6180057110908423 nwt = 15 nko = 25 dwt = pd.DataFrame(np.random.rand(nwt,10)) dko = pd.DataFrame(np.random.rand(nko,10)) A = _get_population(individuals = 10, nwt = nwt, nko = nko, dwt = dwt, dko = dko, geneSet = '01', get_fitness = _get_fitness, obj = [1,0,1,-1,1,0,0,1,0.5, 0.5]) [A_.print() for A_ in A]; 001100101100011 ... 001100101100011 || 010111011100111 ... 001111010101001 7 15 0.22717953288324988 011111001110011 ... 011111001110011 || 110011011010001 ... 100011100110100 10 13 -0.14158703160537597 000111000110010 ... 000111000110010 || 000111011011101 ... 111010101101111 6 16 -0.14752436179984593 111110011001001 ... 111110011001001 || 111101011001011 ... 010111111010101 9 17 0.37230832910925965 111100011100110 ... 111100011100110 || 001000100111010 ... 110100000100011 9 9 0.09942842284405343 011100001011101 ... 011100001011101 || 001010010010100 ... 101000010010000 8 7 -0.29440398210415947 111011011011101 ... 111011011011101 || 000101001001101 ... 011011010111110 11 13 0.262667504755609 000000010010100 ... 000000010010100 || 111110001111110 ... 111101010010111 3 17 -0.3603100204852186 111110110010001 ... 111110110010001 || 100101000011100 ... 111000110100010 9 10 -0.254079327688995 001010010000000 ... 001010010000000 || 100111101001111 ... 011111000011110 3 15 0.3651577081778396","title":"tools._get_population"},{"location":"package/package/tools.html#tools_read_chromosome","text":"This function read the chromosome information from a file and it is loaded in memory. The file can be generated by to_json() method. The docstring associated to the _read_chromosome function is the following. ?_read_chromosome Parameters ---------- path_or_buf : string or file handle. File path or object. Returns ------- This function returns a chromosome Examples -------- >>> A = chromosome(genes = '00100101001001011000111010110010', nko=16, nwt=16, fitness=0.98) >>> A.print(5) 00100 ... 00101 || 10001 ... 10010 6 8 0.98 >>> A.to_json('prueba.json') >>> B = _read_chromosome('prueba.json') >>> B.print(10) 0010010100 ... 0100100101 || 1000111010 ... 1010110010 6 8 0.98 new_CH = _read_chromosome(path_or_buf = 'out.json') new_CH.print() 0110101101 ... 0110101101 || 011000111101101 ... 011010110001111 6 18 0.4125","title":"tools._read_chromosome"},{"location":"publications/congress_conferences_seminars.html","text":"Congress, Conferences & Seminars # Development of Metabolome-Based Predictors of Liver Diseases . Cristina Alonso, Enara Arretxe, Marta Iruarrizaga-Lejarreta, Itziar Minchol\u00e9, Rub\u00e9n Gil-Redondo, Ibon Mart\u00ednez-Arranz , VALDIG Conference, Ascona (Switzerland), 19-22 February, 2017. Noninvasive Serum Biomarkers Reflect the Effect of Aramchol on Mice Fibrotic Livers . Marta Iruarrizaga-Lejarreta, Laura delaCruz-Villar, Marta Varela-Rey, Rebeca Mayo, Ibon Mart\u00ednez-Arranz , David Fern\u00e1ndez-Ramos, Liat Hayardeny, Cristina Alonso, Juan Anguita, M. Luz Mart\u00ednez-Chantar, Jos\u00e9 M Mato, The International Liver CongressTM, Amsterdam, the Netherlands, 19-23 April, 2017. Metabolomics Approach Addresses the Heterogeneity of NAFLD and Determines Subtypes Associated with Different Metabolic Alterations . Marta Iruarrizaga-Lejarreta, Laura delaCruz-Villar, Marta Varela-Rey, Rebeca Mayo, Ibon Mart\u00ednez-Arranz , David Fern\u00e1ndez-Ramos, Liat Hayardeny, Cristina Alonso, Juan Anguita, M. Luz Mart\u00ednez-Chantar, Jos\u00e9 M Mato, The International Liver CongressTM, Washington DC, United States, 20-24 October, 2017. Genetic Algorithms Reveal Potential to Stratify MASKD heterogeneity . Ibon Martinez-Arranz , Dr. Cristina Alonso, Dr. Rebeca Mayo, Ruben Gil-Redondo, Itziar Minchol\u00e9, Alejandro Montilla, \u00d3scar Millet, Mazen Noureddin, Dr. Shelly Lu, Dr. Nicholas Davidson and Prof. Jos\u00e9 M Mato, The International Liver CongressTM, Boston, United States, 10-14 November, 2023.","title":"Congress & Conferences"},{"location":"publications/congress_conferences_seminars.html#congress_conferences_seminars","text":"Development of Metabolome-Based Predictors of Liver Diseases . Cristina Alonso, Enara Arretxe, Marta Iruarrizaga-Lejarreta, Itziar Minchol\u00e9, Rub\u00e9n Gil-Redondo, Ibon Mart\u00ednez-Arranz , VALDIG Conference, Ascona (Switzerland), 19-22 February, 2017. Noninvasive Serum Biomarkers Reflect the Effect of Aramchol on Mice Fibrotic Livers . Marta Iruarrizaga-Lejarreta, Laura delaCruz-Villar, Marta Varela-Rey, Rebeca Mayo, Ibon Mart\u00ednez-Arranz , David Fern\u00e1ndez-Ramos, Liat Hayardeny, Cristina Alonso, Juan Anguita, M. Luz Mart\u00ednez-Chantar, Jos\u00e9 M Mato, The International Liver CongressTM, Amsterdam, the Netherlands, 19-23 April, 2017. Metabolomics Approach Addresses the Heterogeneity of NAFLD and Determines Subtypes Associated with Different Metabolic Alterations . Marta Iruarrizaga-Lejarreta, Laura delaCruz-Villar, Marta Varela-Rey, Rebeca Mayo, Ibon Mart\u00ednez-Arranz , David Fern\u00e1ndez-Ramos, Liat Hayardeny, Cristina Alonso, Juan Anguita, M. Luz Mart\u00ednez-Chantar, Jos\u00e9 M Mato, The International Liver CongressTM, Washington DC, United States, 20-24 October, 2017. Genetic Algorithms Reveal Potential to Stratify MASKD heterogeneity . Ibon Martinez-Arranz , Dr. Cristina Alonso, Dr. Rebeca Mayo, Ruben Gil-Redondo, Itziar Minchol\u00e9, Alejandro Montilla, \u00d3scar Millet, Mazen Noureddin, Dr. Shelly Lu, Dr. Nicholas Davidson and Prof. Jos\u00e9 M Mato, The International Liver CongressTM, Boston, United States, 10-14 November, 2023.","title":"Congress, Conferences &amp; Seminars"},{"location":"publications/metabolomics_subtypes.html","text":"Metabolomics & Subtypes # Currently, there are three publications about subtypes of NASH with three mice models. The first publication was published in 2017. Metabolomic Identification of Subtypes of Nonalcoholic Steatohepatitis # Authors # Cristina Alonso, David Fern\u00e1ndez-Ramos, Marta Varela-Rey, Ibon Mart\u00ednez-Arranz , Nicol\u00e1s Navasa, Sebastiaan M Van Liempd, Jos\u00e9 L Lav\u00edn Trueba, Rebeca Mayo, Concetta P Ilisso, Virginia G de Juan, Marta Iruarrizaga-Lejarreta, Laura delaCruz-Villar, Itziar Minchol\u00e9, Aaron Robinson, Javier Crespo, Antonio Mart\u00edn-Duce, Manuel Romero-G\u00f3mez, Holger Sann, Julian Platon, Jennifer Van Eyk, Patricia Aspichueta, Mazen Noureddin, Juan M Falc\u00f3n-P\u00e9rez, Juan Anguita, Ana M Aransay, Mar\u00eda Luz Mart\u00ednez-Chantar, Shelly C Lu, Jos\u00e9 M Mato (2017). Metabolomic Identification of Subtypes of Nonalcoholic Steatohepatitis. Gastroenterology . Abstract # Nonalcoholic fatty liver disease (NAFLD) is a consequence of defects in diverse metabolic pathways that involve hepatic accumulation of triglycerides. Features of these aberrations might determine whether NAFLD progresses to nonalcoholic steatohepatitis (NASH). We investigated whether the diverse defects observed in patients with NAFLD are due to different NAFLD subtypes with specific serum metabolomic profiles, and whether these can distinguish patients with NASH from patients with simple steatosis. We collected liver and serum from methionine adenosyltransferase 1a knockout (MAT1A-KO) mice, which have chronically low level of hepatic S-adenosylmethionine (SAMe) and spontaneously develop steatohepatitis, as well as C57Bl/6 mice (controls); the metabolomes of all samples were determined. We also analyzed serum metabolomes of 535 patients with biopsy-proven NAFLD (353 with simple steatosis and 182 with NASH) and compared them with serum metabolomes of mice. MAT1A-KO mice were also given SAMe (30 mg/kg/day for 8 weeks); liver samples were collected and analyzed histologically for steatohepatitis. Livers of MAT1A-KO mice were characterized by high levels of triglycerides, diglycerides, fatty acids, ceramides, and oxidized fatty acids, as well as low levels of SAMe and downstream metabolites. There was a correlation between liver and serum metabolomes. We identified a serum metabolomic signature associated with MAT1A-KO mice that was also present in 49% of the patients; based on this signature, we identified 2 NAFLD subtypes. We identified specific panels of markers that could distinguish patients with NASH from patients with simple steatosis for each subtype of NAFLD. Administration of SAMe reduced features of steatohepatitis in MAT1A-KO mice. In an analysis of serum metabolomes of patients with NAFLD and MAT1A-KO mice with steatohepatitis, we identified 2 major subtypes of NAFLD and markers that differentiate steatosis from NASH in each subtype. These might be used to monitor disease progression and identify therapeutic targets for patients. web pdf DOI Pubmed Role of aramchol in steatohepatitis and fibrosis in mice # Authors # Marta Iruarrizaga-Lejarreta, Marta Varela-Rey, David Fern\u00e1ndez-Ramos, Ibon Mart\u00ednez-Arranz , Teresa C Delgado, Jorge Simon, Virginia Guti\u00e9rrez-de Juan, Laura delaCruz-Villar, Mikel Azkargorta, Jos\u00e9 L Lavin, Rebeca Mayo, Sebastiaan M Van Liempd, Igor Aurrekoetxea, Xabier Buqu\u00e9, Donatella Delle Cave, Arantza Pe\u00f1a, Juan Rodr\u00edguez-Cuesta, Ana M Aransay, Felix Elortza, Juan M Falc\u00f3n-P\u00e9rez, Patricia Aspichueta, Liat Hayardeny, Mazen Noureddin, Arun J Sanyal, Cristina Alonso, Juan Anguita, Mar\u00eda Luz Mart\u00ednez-Chantar, Shelly C Lu, Jos\u00e9 M Mato (2017). Role of aramchol in steatohepatitis and fibrosis in mice. Hepatology Communications . Abstract # Nonalcoholic steatohepatitis (NASH) is the advanced form of nonalcoholic fatty liver disease (NAFLD) that sets the stage for further liver damage. The mechanism for the progression of NASH involves multiple parallel hits, including oxidative stress, mitochondrial dysfunction, inflammation, and others. Manipulation of any of these pathways may be an approach to prevent NASH development and progression. Arachidyl-amido cholanoic acid (Aramchol) is presently in a phase IIb NASH study. The aim of the present study was to investigate Aramchol's mechanism of action and its effect on fibrosis using the methionine- and choline-deficient (MCD) diet model of NASH. We collected liver and serum from mice fed an MCD diet containing 0.1% methionine (0.1MCD) for 4 weeks; these mice developed steatohepatitis and fibrosis. We also collected liver and serum from mice receiving a control diet, and metabolomes and proteomes were determined for both groups. The 0.1MCD-fed mice were given Aramchol (5 mg/kg/day for the last 2 weeks), and liver samples were analyzed histologically. Aramchol administration reduced features of steatohepatitis and fibrosis in 0.1MCD-fed mice. Aramchol down-regulated stearoyl-coenyzme A desaturase 1, a key enzyme involved in triglyceride biosynthesis and the loss of which enhances fatty acid \u03b2-oxidation. Aramchol increased the flux through the transsulfuration pathway, leading to a rise in glutathione (GSH) and the GSH/oxidized GSH ratio, the main cellular antioxidant that maintains intracellular redox status. Comparison of the serum metabolomic pattern between 0.1MCD-fed mice and patients with NAFLD showed a substantial overlap. Conclusion: Aramchol treatment improved steatohepatitis and fibrosis by 1) decreasing stearoyl-coenyzme A desaturase 1 and 2) increasing the flux through the transsulfuration pathway maintaining cellular redox homeostasis. We also demonstrated that the 0.1MCD model resembles the metabolic phenotype observed in about 50% of patients with NAFLD, which supports the potential use of Aramchol in NASH treatment. (Hepatology Communications 2017). web DOI Pubmed Obeticholic Acid Modulates Serum Metabolites and Gene Signatures Characteristic of Human NASH and Attenuates Inflammation and Fibrosis Progression in Ldlr-/-.Leiden Mice # Authors # Martine C Morrison, Lars Verschuren, Kanita Salic, Joanne Verheij, Aswin Menke, Peter Y Wielinga, Marta Iruarrizaga-Lejarreta, Laurent Gole, Wei-Miao Yu, Scott Turner, Martien P M Caspers, Ibon Mart\u00ednez-Arranz , Elsbet Pieterman, Reinout Stoop, Arianne van Koppen, Anita M van den Hoek, Jos\u00e9 M Mato, Roeland Hanemaaijer, Cristina Alonso, Robert Kleemann (2018). Obeticholic Acid Modulates Serum Metabolites and Gene Signatures Characteristic of Human NASH and Attenuates Inflammation and Fibrosis Progression in Ldlr-/-.Leiden Mice. Hepatology Communications , 2 (12), 1513\u20131532. https://doi.org/10.1002/hep4.1270 Abstract # Concerns have been raised about whether preclinical models sufficiently mimic molecular disease processes observed in nonalcoholic steatohepatitis (NASH) patients, bringing into question their translational value in studies of therapeutic interventions in the process of NASH/fibrosis. We investigated the representation of molecular disease patterns characteristic for human NASH in high-fat diet (HFD)-fed Ldlr-/-.Leiden mice and studied the effects of obeticholic acid (OCA) on these disease profiles. Multiplatform serum metabolomic profiles and genome-wide liver transcriptome from HFD-fed Ldlr-/-.Leiden mice were compared with those of NASH patients. Mice were profiled at the stage of mild (24 weeks HFD) and severe (34 weeks HFD) fibrosis, and after OCA intervention (24-34 weeks; 10 mg/kg/day). Effects of OCA were analyzed histologically, biochemically, by immunohistochemistry, using deuterated water technology (de novo collagen formation), and by its effect on the human-based transcriptomics and metabolomics signatures. The transcriptomics and metabolomics profile of Ldlr-/-.Leiden mice largely reflected the molecular signature of NASH patients. OCA modulated the expression of these molecular profiles and quenched specific proinflammatory-profibrotic pathways. OCA attenuated specific facets of cellular inflammation in liver (F4/80-positive cells) and reduced crown-like structures in adipose tissue. OCA reduced de novo collagen formation and attenuated further progression of liver fibrosis, but did not reduce fibrosis below the level before intervention. Conclusion: HFD-fed Ldlr-/-.Leiden mice recapitulate molecular transcriptomic and metabolomic profiles of NASH patients, and these signatures are modulated by OCA. Intervention with OCA in developing fibrosis reduces collagen deposition and de novo synthesis but does not resolve already manifest fibrosis in the period studied. These data show that human molecular signatures can be used to evaluate the translational character of preclinical models for NASH. web DOI Pubmed","title":"Metabolomics Subtypes"},{"location":"publications/metabolomics_subtypes.html#metabolomics_subtypes","text":"Currently, there are three publications about subtypes of NASH with three mice models. The first publication was published in 2017.","title":"Metabolomics &amp; Subtypes"},{"location":"publications/metabolomics_subtypes.html#metabolomic_identification_of_subtypes_of_nonalcoholic_steatohepatitis","text":"","title":"Metabolomic Identification of Subtypes of Nonalcoholic Steatohepatitis"},{"location":"publications/metabolomics_subtypes.html#authors","text":"Cristina Alonso, David Fern\u00e1ndez-Ramos, Marta Varela-Rey, Ibon Mart\u00ednez-Arranz , Nicol\u00e1s Navasa, Sebastiaan M Van Liempd, Jos\u00e9 L Lav\u00edn Trueba, Rebeca Mayo, Concetta P Ilisso, Virginia G de Juan, Marta Iruarrizaga-Lejarreta, Laura delaCruz-Villar, Itziar Minchol\u00e9, Aaron Robinson, Javier Crespo, Antonio Mart\u00edn-Duce, Manuel Romero-G\u00f3mez, Holger Sann, Julian Platon, Jennifer Van Eyk, Patricia Aspichueta, Mazen Noureddin, Juan M Falc\u00f3n-P\u00e9rez, Juan Anguita, Ana M Aransay, Mar\u00eda Luz Mart\u00ednez-Chantar, Shelly C Lu, Jos\u00e9 M Mato (2017). Metabolomic Identification of Subtypes of Nonalcoholic Steatohepatitis. Gastroenterology .","title":"Authors"},{"location":"publications/metabolomics_subtypes.html#abstract","text":"Nonalcoholic fatty liver disease (NAFLD) is a consequence of defects in diverse metabolic pathways that involve hepatic accumulation of triglycerides. Features of these aberrations might determine whether NAFLD progresses to nonalcoholic steatohepatitis (NASH). We investigated whether the diverse defects observed in patients with NAFLD are due to different NAFLD subtypes with specific serum metabolomic profiles, and whether these can distinguish patients with NASH from patients with simple steatosis. We collected liver and serum from methionine adenosyltransferase 1a knockout (MAT1A-KO) mice, which have chronically low level of hepatic S-adenosylmethionine (SAMe) and spontaneously develop steatohepatitis, as well as C57Bl/6 mice (controls); the metabolomes of all samples were determined. We also analyzed serum metabolomes of 535 patients with biopsy-proven NAFLD (353 with simple steatosis and 182 with NASH) and compared them with serum metabolomes of mice. MAT1A-KO mice were also given SAMe (30 mg/kg/day for 8 weeks); liver samples were collected and analyzed histologically for steatohepatitis. Livers of MAT1A-KO mice were characterized by high levels of triglycerides, diglycerides, fatty acids, ceramides, and oxidized fatty acids, as well as low levels of SAMe and downstream metabolites. There was a correlation between liver and serum metabolomes. We identified a serum metabolomic signature associated with MAT1A-KO mice that was also present in 49% of the patients; based on this signature, we identified 2 NAFLD subtypes. We identified specific panels of markers that could distinguish patients with NASH from patients with simple steatosis for each subtype of NAFLD. Administration of SAMe reduced features of steatohepatitis in MAT1A-KO mice. In an analysis of serum metabolomes of patients with NAFLD and MAT1A-KO mice with steatohepatitis, we identified 2 major subtypes of NAFLD and markers that differentiate steatosis from NASH in each subtype. These might be used to monitor disease progression and identify therapeutic targets for patients. web pdf DOI Pubmed","title":"Abstract"},{"location":"publications/metabolomics_subtypes.html#role_of_aramchol_in_steatohepatitis_and_fibrosis_in_mice","text":"","title":"Role of aramchol in steatohepatitis and fibrosis in mice"},{"location":"publications/metabolomics_subtypes.html#authors_1","text":"Marta Iruarrizaga-Lejarreta, Marta Varela-Rey, David Fern\u00e1ndez-Ramos, Ibon Mart\u00ednez-Arranz , Teresa C Delgado, Jorge Simon, Virginia Guti\u00e9rrez-de Juan, Laura delaCruz-Villar, Mikel Azkargorta, Jos\u00e9 L Lavin, Rebeca Mayo, Sebastiaan M Van Liempd, Igor Aurrekoetxea, Xabier Buqu\u00e9, Donatella Delle Cave, Arantza Pe\u00f1a, Juan Rodr\u00edguez-Cuesta, Ana M Aransay, Felix Elortza, Juan M Falc\u00f3n-P\u00e9rez, Patricia Aspichueta, Liat Hayardeny, Mazen Noureddin, Arun J Sanyal, Cristina Alonso, Juan Anguita, Mar\u00eda Luz Mart\u00ednez-Chantar, Shelly C Lu, Jos\u00e9 M Mato (2017). Role of aramchol in steatohepatitis and fibrosis in mice. Hepatology Communications .","title":"Authors"},{"location":"publications/metabolomics_subtypes.html#abstract_1","text":"Nonalcoholic steatohepatitis (NASH) is the advanced form of nonalcoholic fatty liver disease (NAFLD) that sets the stage for further liver damage. The mechanism for the progression of NASH involves multiple parallel hits, including oxidative stress, mitochondrial dysfunction, inflammation, and others. Manipulation of any of these pathways may be an approach to prevent NASH development and progression. Arachidyl-amido cholanoic acid (Aramchol) is presently in a phase IIb NASH study. The aim of the present study was to investigate Aramchol's mechanism of action and its effect on fibrosis using the methionine- and choline-deficient (MCD) diet model of NASH. We collected liver and serum from mice fed an MCD diet containing 0.1% methionine (0.1MCD) for 4 weeks; these mice developed steatohepatitis and fibrosis. We also collected liver and serum from mice receiving a control diet, and metabolomes and proteomes were determined for both groups. The 0.1MCD-fed mice were given Aramchol (5 mg/kg/day for the last 2 weeks), and liver samples were analyzed histologically. Aramchol administration reduced features of steatohepatitis and fibrosis in 0.1MCD-fed mice. Aramchol down-regulated stearoyl-coenyzme A desaturase 1, a key enzyme involved in triglyceride biosynthesis and the loss of which enhances fatty acid \u03b2-oxidation. Aramchol increased the flux through the transsulfuration pathway, leading to a rise in glutathione (GSH) and the GSH/oxidized GSH ratio, the main cellular antioxidant that maintains intracellular redox status. Comparison of the serum metabolomic pattern between 0.1MCD-fed mice and patients with NAFLD showed a substantial overlap. Conclusion: Aramchol treatment improved steatohepatitis and fibrosis by 1) decreasing stearoyl-coenyzme A desaturase 1 and 2) increasing the flux through the transsulfuration pathway maintaining cellular redox homeostasis. We also demonstrated that the 0.1MCD model resembles the metabolic phenotype observed in about 50% of patients with NAFLD, which supports the potential use of Aramchol in NASH treatment. (Hepatology Communications 2017). web DOI Pubmed","title":"Abstract"},{"location":"publications/metabolomics_subtypes.html#obeticholic_acid_modulates_serum_metabolites_and_gene_signatures_characteristic_of_human_nash_and_attenuates_inflammation_and_fibrosis_progression_in_ldlr--leiden_mice","text":"","title":"Obeticholic Acid Modulates Serum Metabolites and Gene Signatures Characteristic of Human NASH and Attenuates Inflammation and Fibrosis Progression in Ldlr-/-.Leiden Mice"},{"location":"publications/metabolomics_subtypes.html#authors_2","text":"Martine C Morrison, Lars Verschuren, Kanita Salic, Joanne Verheij, Aswin Menke, Peter Y Wielinga, Marta Iruarrizaga-Lejarreta, Laurent Gole, Wei-Miao Yu, Scott Turner, Martien P M Caspers, Ibon Mart\u00ednez-Arranz , Elsbet Pieterman, Reinout Stoop, Arianne van Koppen, Anita M van den Hoek, Jos\u00e9 M Mato, Roeland Hanemaaijer, Cristina Alonso, Robert Kleemann (2018). Obeticholic Acid Modulates Serum Metabolites and Gene Signatures Characteristic of Human NASH and Attenuates Inflammation and Fibrosis Progression in Ldlr-/-.Leiden Mice. Hepatology Communications , 2 (12), 1513\u20131532. https://doi.org/10.1002/hep4.1270","title":"Authors"},{"location":"publications/metabolomics_subtypes.html#abstract_2","text":"Concerns have been raised about whether preclinical models sufficiently mimic molecular disease processes observed in nonalcoholic steatohepatitis (NASH) patients, bringing into question their translational value in studies of therapeutic interventions in the process of NASH/fibrosis. We investigated the representation of molecular disease patterns characteristic for human NASH in high-fat diet (HFD)-fed Ldlr-/-.Leiden mice and studied the effects of obeticholic acid (OCA) on these disease profiles. Multiplatform serum metabolomic profiles and genome-wide liver transcriptome from HFD-fed Ldlr-/-.Leiden mice were compared with those of NASH patients. Mice were profiled at the stage of mild (24 weeks HFD) and severe (34 weeks HFD) fibrosis, and after OCA intervention (24-34 weeks; 10 mg/kg/day). Effects of OCA were analyzed histologically, biochemically, by immunohistochemistry, using deuterated water technology (de novo collagen formation), and by its effect on the human-based transcriptomics and metabolomics signatures. The transcriptomics and metabolomics profile of Ldlr-/-.Leiden mice largely reflected the molecular signature of NASH patients. OCA modulated the expression of these molecular profiles and quenched specific proinflammatory-profibrotic pathways. OCA attenuated specific facets of cellular inflammation in liver (F4/80-positive cells) and reduced crown-like structures in adipose tissue. OCA reduced de novo collagen formation and attenuated further progression of liver fibrosis, but did not reduce fibrosis below the level before intervention. Conclusion: HFD-fed Ldlr-/-.Leiden mice recapitulate molecular transcriptomic and metabolomic profiles of NASH patients, and these signatures are modulated by OCA. Intervention with OCA in developing fibrosis reduces collagen deposition and de novo synthesis but does not resolve already manifest fibrosis in the period studied. These data show that human molecular signatures can be used to evaluate the translational character of preclinical models for NASH. web DOI Pubmed","title":"Abstract"},{"location":"publications/publications.html","text":"Publications # Articles # Data Science # Mart\u00ednez-Arranz, I., Mayo, R., P\u00e9rez-Cormenzana, M., Minchol\u00e9, I., Salazar, L., Alonso, C., & Mato, J. M. (2015). Data in support of enhancing metabolomics research through data mining. Data in Brief , 3 , 155\u2013164. https://doi.org/10.1016/j.dib.2015.02.008 Martinez-Arranz, I., Mayo, R., P\u00e9rez-Cormenzana, M., Minchol\u00e9, I., Salazar, L., Alonso, C., & Mato, J. M. (2015). Enhancing metabolomics research through data mining. J Proteomics , 127 (Pt B), 275\u2013288. https://doi.org/10.1016/j.jprot.2015.01.019 Michelena, J., Alonso, C., Mart\u00ednez-Arranz, I., Altamirano, J., Mayo, R., Sancho-Bru, P., \u2026 Caballer\u00eda, J. (2018). Metabolomics Discloses a New Non-invasive Method for the Diagnosis and Prognosis of Patients with Alcoholic Hepatitis. Annals of Hepatology , 18 (1), 144\u2013154. https://doi.org/10.5604/01.3001.0012.7906 Banales, J. M., I\u00f1arrairaegui, M., Arbelaiz, A., Milkiewicz, P., Muntan\u00e9, J., Mu\u00f1oz-Bellvis, L., \u2026 Macias, R. I. R. (2019). Serum Metabolites as Diagnostic Biomarkers for Cholangiocarcinoma, Hepatocellular Carcinoma, and Primary Sclerosing Cholangitis. Hepatology , 70 (2), 547\u2013562. https://doi.org/10.1002/hep.30319 Metabolomics # Barr, J., Caballer\u00eda, J., Mart\u00ednez-Arranz, I., Dom\u00ednguez-D\u00edez, A., Alonso, C., Muntan\u00e9, J., \u2026 Mato, J. M. (2012). Obesity-dependent metabolic signatures associated with nonalcoholic fatty liver disease progression. J Proteome Res , 11 (4), 2521\u20132532. https://doi.org/10.1021/pr201223p Mart\u00ednez-U\u00f1a, M., Varela-Rey, M., Cano, A., Fern\u00e1ndez-Ares, L., Beraza, N., Aurrekoetxea, I., \u2026 Mato, J. M. (2013). Excess S-adenosylmethionine reroutes phosphatidylethanolamine towards phosphatidylcholine and triglyceride synthesis. Hepatology , 58 (4), 1296\u20131305. https://doi.org/10.1002/hep.26399 Vazquez-Chantada, M., Gonzalez-Lahera, A., Martinez-Arranz, I., Garcia-Monzon, C., Regueiro, M. M., Garcia-Rodriguez, J. L., \u2026 Aransay, A. M. (2013). Solute carrier family 2 member 1 is involved in the development of nonalcoholic fatty liver disease. Hepatology , 57 (2), 505\u2013514. https://doi.org/10.1002/hep.26052 Arbelaiz, A., Azkargorta, M., Krawczyk, M., Santos-Laso, A., Lapitz, A., Perugorria, M. J., \u2026 Banales, J. M. (2017). Serum extracellular vesicles contain protein biomarkers for primary sclerosing cholangitis and cholangiocarcinoma: Extracellular vesicles in PSC, CCA and HCC. Hepatology . https://doi.org/10.1002/hep.29291 Cano, A., Mari\u00f1o, Z., Millet, O., Mart\u00ednez-Arranz, I., Navasa, M., Falc\u00f3n-P\u00e9rez, J. M., \u2026 Mato, J. M. (2017). A Metabolomics Signature Linked to Liver Fibrosis in the Serum of Transplanted Hepatitis C Patients. Scientific Reports , 7 (1), 10497. https://doi.org/10.1038/s41598-017-10807-y Cubiella, J., Clos-Garcia, M., Alonso, C., Martinez-Arranz, I., Perez-Cormenzana, M., Barrenetxea, Z., \u2026 Falc\u00f3n-P\u00e9rez, J. M. (2018). Targeted UPLC-MS Metabolic Analysis of Human Faeces Reveals Novel Low-Invasive Candidate Markers for Colorectal Cancer. Cancers , 10 (9). https://doi.org/10.3390/cancers10090300 Mayo, R., Crespo, J., Mart\u00ednez\u2010Arranz, I., Banales, J. M., Arias, M., Minchol\u00e9, I., \u2026 Mato, J. M. (2018). Metabolomic\u2010based noninvasive serum test to diagnose nonalcoholic steatohepatitis: Results from discovery and validation cohorts. Hepatology Communications , 2 (7), 807\u2013820. https://doi.org/10.1002/hep4.1188 Bril, F., Mill\u00e1n, L., Kalavalapalli, S., McPhaul, M. J., Caulfield, M. P., Martinez-Arranz, I., \u2026 Cusi, K. (n.d.). Use of a metabolomic approach to non-invasively diagnose non-alcoholic fatty liver disease in patients with type 2 diabetes mellitus. Diabetes, Obesity and Metabolism , 0 (0). https://doi.org/10.1111/dom.13285 Herreros-Villanueva, M., Duran-Sanchon, S., Mart\u00edn, A. C., P\u00e9rez-Palacios, R., Vila-Navarro, E., Marcuello, M., \u2026 Arroyo, R. (2019). Plasma MicroRNA Signature Validation for Early Detection of Colorectal Cancer. Clinical and Translational Gastroenterology , 10 (1), e00003. https://doi.org/10.14309/ctg.0000000000000003 Reverter, E., Lozano, J. J., Alonso, C., Berzigotti, A., Seijo, S., Turon, F., \u2026 Garc\u00eda\u2010Pag\u00e1n, J. C. (2019). Metabolomics discloses potential biomarkers to predict the acute HVPG response to propranolol in patients with cirrhosis. Liver International , 39 (4), 705\u2013713. https://doi.org/10.1111/liv.14042 More Information # PUBMED","title":"Publications"},{"location":"publications/publications.html#publications","text":"","title":"Publications"},{"location":"publications/publications.html#articles","text":"","title":"Articles"},{"location":"publications/publications.html#data_science","text":"Mart\u00ednez-Arranz, I., Mayo, R., P\u00e9rez-Cormenzana, M., Minchol\u00e9, I., Salazar, L., Alonso, C., & Mato, J. M. (2015). Data in support of enhancing metabolomics research through data mining. Data in Brief , 3 , 155\u2013164. https://doi.org/10.1016/j.dib.2015.02.008 Martinez-Arranz, I., Mayo, R., P\u00e9rez-Cormenzana, M., Minchol\u00e9, I., Salazar, L., Alonso, C., & Mato, J. M. (2015). Enhancing metabolomics research through data mining. J Proteomics , 127 (Pt B), 275\u2013288. https://doi.org/10.1016/j.jprot.2015.01.019 Michelena, J., Alonso, C., Mart\u00ednez-Arranz, I., Altamirano, J., Mayo, R., Sancho-Bru, P., \u2026 Caballer\u00eda, J. (2018). Metabolomics Discloses a New Non-invasive Method for the Diagnosis and Prognosis of Patients with Alcoholic Hepatitis. Annals of Hepatology , 18 (1), 144\u2013154. https://doi.org/10.5604/01.3001.0012.7906 Banales, J. M., I\u00f1arrairaegui, M., Arbelaiz, A., Milkiewicz, P., Muntan\u00e9, J., Mu\u00f1oz-Bellvis, L., \u2026 Macias, R. I. R. (2019). Serum Metabolites as Diagnostic Biomarkers for Cholangiocarcinoma, Hepatocellular Carcinoma, and Primary Sclerosing Cholangitis. Hepatology , 70 (2), 547\u2013562. https://doi.org/10.1002/hep.30319","title":"Data Science"},{"location":"publications/publications.html#metabolomics","text":"Barr, J., Caballer\u00eda, J., Mart\u00ednez-Arranz, I., Dom\u00ednguez-D\u00edez, A., Alonso, C., Muntan\u00e9, J., \u2026 Mato, J. M. (2012). Obesity-dependent metabolic signatures associated with nonalcoholic fatty liver disease progression. J Proteome Res , 11 (4), 2521\u20132532. https://doi.org/10.1021/pr201223p Mart\u00ednez-U\u00f1a, M., Varela-Rey, M., Cano, A., Fern\u00e1ndez-Ares, L., Beraza, N., Aurrekoetxea, I., \u2026 Mato, J. M. (2013). Excess S-adenosylmethionine reroutes phosphatidylethanolamine towards phosphatidylcholine and triglyceride synthesis. Hepatology , 58 (4), 1296\u20131305. https://doi.org/10.1002/hep.26399 Vazquez-Chantada, M., Gonzalez-Lahera, A., Martinez-Arranz, I., Garcia-Monzon, C., Regueiro, M. M., Garcia-Rodriguez, J. L., \u2026 Aransay, A. M. (2013). Solute carrier family 2 member 1 is involved in the development of nonalcoholic fatty liver disease. Hepatology , 57 (2), 505\u2013514. https://doi.org/10.1002/hep.26052 Arbelaiz, A., Azkargorta, M., Krawczyk, M., Santos-Laso, A., Lapitz, A., Perugorria, M. J., \u2026 Banales, J. M. (2017). Serum extracellular vesicles contain protein biomarkers for primary sclerosing cholangitis and cholangiocarcinoma: Extracellular vesicles in PSC, CCA and HCC. Hepatology . https://doi.org/10.1002/hep.29291 Cano, A., Mari\u00f1o, Z., Millet, O., Mart\u00ednez-Arranz, I., Navasa, M., Falc\u00f3n-P\u00e9rez, J. M., \u2026 Mato, J. M. (2017). A Metabolomics Signature Linked to Liver Fibrosis in the Serum of Transplanted Hepatitis C Patients. Scientific Reports , 7 (1), 10497. https://doi.org/10.1038/s41598-017-10807-y Cubiella, J., Clos-Garcia, M., Alonso, C., Martinez-Arranz, I., Perez-Cormenzana, M., Barrenetxea, Z., \u2026 Falc\u00f3n-P\u00e9rez, J. M. (2018). Targeted UPLC-MS Metabolic Analysis of Human Faeces Reveals Novel Low-Invasive Candidate Markers for Colorectal Cancer. Cancers , 10 (9). https://doi.org/10.3390/cancers10090300 Mayo, R., Crespo, J., Mart\u00ednez\u2010Arranz, I., Banales, J. M., Arias, M., Minchol\u00e9, I., \u2026 Mato, J. M. (2018). Metabolomic\u2010based noninvasive serum test to diagnose nonalcoholic steatohepatitis: Results from discovery and validation cohorts. Hepatology Communications , 2 (7), 807\u2013820. https://doi.org/10.1002/hep4.1188 Bril, F., Mill\u00e1n, L., Kalavalapalli, S., McPhaul, M. J., Caulfield, M. P., Martinez-Arranz, I., \u2026 Cusi, K. (n.d.). Use of a metabolomic approach to non-invasively diagnose non-alcoholic fatty liver disease in patients with type 2 diabetes mellitus. Diabetes, Obesity and Metabolism , 0 (0). https://doi.org/10.1111/dom.13285 Herreros-Villanueva, M., Duran-Sanchon, S., Mart\u00edn, A. C., P\u00e9rez-Palacios, R., Vila-Navarro, E., Marcuello, M., \u2026 Arroyo, R. (2019). Plasma MicroRNA Signature Validation for Early Detection of Colorectal Cancer. Clinical and Translational Gastroenterology , 10 (1), e00003. https://doi.org/10.14309/ctg.0000000000000003 Reverter, E., Lozano, J. J., Alonso, C., Berzigotti, A., Seijo, S., Turon, F., \u2026 Garc\u00eda\u2010Pag\u00e1n, J. C. (2019). Metabolomics discloses potential biomarkers to predict the acute HVPG response to propranolol in patients with cirrhosis. Liver International , 39 (4), 705\u2013713. https://doi.org/10.1111/liv.14042","title":"Metabolomics"},{"location":"publications/publications.html#more_information","text":"PUBMED","title":"More Information"}]}